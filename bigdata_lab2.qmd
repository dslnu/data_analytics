---
title: "Big Data Analytics: Lab 2"
execute:
  enabled: true
  echo: true
  cache: true
format:
  html:
    code-fold: false
jupyter: python3
diagram:
  cache: true
  cache-dir: ./cache
  engine:
    tikz:
      execpath: lualatex
filters:
  - diagram
---

## Cython

First, install Cython and Numba:
```python
uv add cython
uv add numba
```

Then we can load Cython extension in Jupyter:
```{python}
%load_ext Cython
```

Define a function that generates a list of first $n$ primes:

:::{.callout-important icon=false}
## Pure Python
```{python}
def primes1(nb_primes):
    p = [0] * 1000
    if nb_primes > 1000:
        nb_primes = 1000

    len_p = 0  # The current number of elements in p.
    n = 2
    while len_p < nb_primes:
        # Is n prime?
        for i in p[:len_p]:
            if n % i == 0:
                break

        # If no break occurred in the loop, we have a prime.
        else:
            p[len_p] = n
            len_p += 1
        n += 1

    # Let's copy the result into a Python list:
    result_as_list = [prime for prime in p[:len_p]]
    return result_as_list
```
:::

:::{.callout-important icon=false}
## Pure Python results
We can measure its execution time:
```{python}
%timeit primes1(100)
```
:::

Now, define a function using Cython type annotations. Note that we use `%%cython` magic before function definition:

:::{.callout-note icon=false}
## Python with Cython type hints
```{python}
%%cython
def primes2(nb_primes: cython.int):
    i: cython.int
    p: cython.int[1000] = [0] * 1000

    if nb_primes > 1000:
        nb_primes = 1000

    len_p: cython.int = 0  # The current number of elements in p.
    n: cython.int = 2
    while len_p < nb_primes:
        # Is n prime?
        for i in p[:len_p]:
            if n % i == 0:
                break

        # If no break occurred in the loop, we have a prime.
        else:
            p[len_p] = n
            len_p += 1
        n += 1

    # Let's copy the result into a Python list:
    result_as_list = [prime for prime in p[:len_p]]
    return result_as_list
```
:::

:::{.callout-note icon=false}
## Python with Cython type hints: results
We measure its execution time:
```{python}
%timeit primes2(100)
```
:::

Different syntax:

:::{.callout-tip icon=false}
## Cython syntax
```{python}
%%cython
def primes3(int nb_primes):
    cdef int n, i, len_p
    cdef int[1000] p

    if nb_primes > 1000:
        nb_primes = 1000

    len_p = 0  # The current number of elements in p.
    n = 2
    while len_p < nb_primes:
        # Is n prime?
        for i in p[:len_p]:
            if n % i == 0:
                break

        # If no break occurred in the loop, we have a prime.
        else:
            p[len_p] = n
            len_p += 1
        n += 1

    # Let's copy the result into a Python list:
    result_as_list = [prime for prime in p[:len_p]]
    return result_as_list
```
:::

:::{.callout-tip icon=false}
## Cython syntax results
We measure its execution time:
```{python}
%timeit primes3(100)
```
:::

:::{.callout-note}
Passing `--annotate` flag will produce more relevant info.
:::

## Using Cython in Pandas

Define a random DataFrame:

```{python}
import pandas as pd
import numpy as np

df = pd.DataFrame(
    {
        "a": np.random.randn(1000),
        "b": np.random.randn(1000),
        "N": np.random.randint(100, 1000, (1000)),
        "x": "x",
    }
)

```

Define functions that will be applied to the DataFrame:

:::{.callout-important icon=false}
## Pure Python
```{python}
def f(x):
    return x * (x - 1)


def integrate_f(a, b, N):
    s = 0
    dx = (b - a) / N
    for i in range(N):
        s += f(a + i * dx)
    return s * dx

```
:::

:::{.callout-important icon=false}
## Pure Python results
Apply functions to DataFrame:
```{python}
%timeit df.apply(lambda x: integrate_f(x["a"], x["b"], x["N"]), axis=1)
```
:::

Now let's use Cython-annotated functions:

:::{.callout-note icon=false}
## Python with Cython type hints
```{python}
%%cython
def f_typed2(x: cython.double) -> cython.double:
    return x * (x - 1)

def integrate_f_typed2(a: cython.double, b: cython.double, N: cython.int) -> cython.double:
    i: cython.int
    s: cython.double
    dx: cython.double
    s = 0
    dx = (b - a) / N
    for i in range(N):
        s += f_typed2(a + i * dx)
    return s * dx

```
:::

:::{.callout-note icon=false}
## Python with Cython type hints
Apply annotated functions to DataFrame:
```{python}
%timeit df.apply(lambda x: integrate_f_typed2(x["a"], x["b"], x["N"]), axis=1)
```
:::


With a different syntax:

:::{.callout-tip icon=false}
## Cython syntax
```{python}
%%cython
cdef double f_typed(double x) except? -2:
   return x * (x - 1)
cpdef double integrate_f_typed(double a, double b, int N):
   cdef int i
   cdef double s, dx
   s = 0
   dx = (b - a) / N
   for i in range(N):
       s += f_typed(a + i * dx)
   return s * dx

```
:::

:::{.callout-tip icon=false}
## Cython syntax results
```{python}
%timeit df.apply(lambda x: integrate_f_typed(x["a"], x["b"], x["N"]), axis=1)
```
:::

:::{.callout-note}
## Pandas
Read more about type annotations for Pandas: <https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html>.
:::


## Numba

Either add `engine="numba"` parameter to Pandas functions, or add a `@jit` annotation to Python funcs.

:::{.callout-warning icon=false}
## Numba-annotated code
```{python}
import numba


@numba.jit
def f_numba(x):
    return x * (x - 1)


@numba.jit
def integrate_f_numba(a, b, N):
    s = 0
    dx = (b - a) / N
    for i in range(N):
        s += f_numba(a + i * dx)
    return s * dx


@numba.jit
def apply_integrate_f_numba(col_a, col_b, col_N):
    n = len(col_N)
    result = np.empty(n, dtype="float64")
    assert len(col_a) == len(col_b) == n
    for i in range(n):
        result[i] = integrate_f_numba(col_a[i], col_b[i], col_N[i])
    return result


def compute_numba(df):
    result = apply_integrate_f_numba(
        df["a"].to_numpy(), df["b"].to_numpy(), df["N"].to_numpy()
    )
    return pd.Series(result, index=df.index, name="result")
```
:::

:::{.callout-warning icon=false}
## Numba Results
```{python}
%timeit compute_numba(df)
```
:::


## Exercises

1. Apply Cython/Numba optimizations to some computations on your dataframe from Lab 1.
2. Go through the tutorial on Black-Scholes option pricing (<https://louis-finegan.github.io/2024/10/10/Black-Scholes.html>). Modify the code so that:
  - it works for some different company
  - has 2 versions: using Cython and Numba
  - measure results

## References

1. [Cython tutorial](https://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html)
2. [Cython build instructions](https://cython.readthedocs.io/en/latest/src/quickstart/build.html)
3. [Cython language](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html)
4. [Pandas optimization](https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html)
