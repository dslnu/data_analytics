---
title: "Big Data: Intro"
author: 
  - name: MSDE
    affiliation: Lviv University
code-fold: false
execute:
  enabled: false
  cache: true
diagram:
  cache: true
  cache-dir: ./cache
  engine:
    tikz:
      execpath: lualatex
      additional-packages: |
        \usetikzlibrary{arrows.meta}
        \usetikzlibrary{positioning}
        \usetikzlibrary{decorations.pathreplacing}
filters:
  - diagram
format: 
  revealjs:
    preview-links: auto
    slide-number: true
    theme: default
    multiplex:
      url: 'https://mplex.vitv.ly'
      secret: 'fad1947f4c744674d25d0769c690f8d7'
      id: 'ceb96efc411836bb262565b446653921d89b7ccf140a4d923b70660482df2ced'
---


## What is Big Data?
:::{.callout-important icon=false}
## Definition
 Big Data is a set of technologies designed to store, manage and analyze data that is:

- too large to fit on a single machine 
- while accommodating for the issue of growing discrepancy between capacity, throughput and latency.
:::

## Prefixes
:::{.callout-important icon=false}
## Prefixes

- **kilo (k)** 1,000 (3 zeros)
- **Mega (M)** 1,000,000 (6 zeros)
- **Giga (G)** 1,000,000,000 (9 zeros)
- **Tera (T)** 1,000,000,000,000 (12 zeros)
- **Peta (P)** 1,000,000,000,000,000 (15 zeros)
- **Exa (E)** 1,000,000,000,000,000,000 (18 zeros)
- **Zetta (Z)** 1,000,000,000,000,000,000,000 (21 zeros)
- **Yotta (Y)** 1,000,000,000,000,000,000,000,000 (24 zeros)
- **Ronna (R)** 1,000,000,000,000,000,000,000,000,000 (27 zeros)
- **Quetta (Q)** 1,000,000,000,000,000,000,000,000,000,000 (30 zeros) 
:::

## Total estimate
:::{.callout-important icon=false}
## Estimate
The total amount of data stored digitally worldwide is estimated to be getting close to 100 ZB as of 2021 (zettabytes) 
:::

![](img/total_data_vol)

# The three Vs of Big Data

## Three Vs
:::: {.columns}

::: {.column width="30%" background-color="lightgray"}
- **Volume**
- **Variety**
- **Velocity**
:::

::: {.column width="70%"}
![](img/3vs)
:::

::::

## Volume
:::{.callout-important icon=false}
## Issue
Data volume has exponentially increased in recent decades.
:::

:::{.callout-tip icon=false}
## Wait but why?

- Internet-of-Things sensor data
- Social networks
- Storage device progress
:::

## Variety
:::{.callout-important icon=false}
## Types

- **trees** - XML, JSON, Parquet, Avro, etc
- **unstructured** - text, pictures, audio, video
- **data cubes**
- **graphs**
:::

## Velocity
:::{.callout-note icon=false}
## Definion
Speed at which data is being generated, collected, and processed. 
:::
:::{.callout-important icon=false}
## Attributes

- **Capacity**: how much data can we store per unit of volume?
- **Throughput**: how many bytes can we read per unit of time?
- **Latency**: how much time do we need to wait until the bytes start arriving?
:::

## Velocity
Evolution since 1950s
![](img/velocity)

# Features of Big Data systems

## Features
:::{.callout-note icon=false}
## Features

- **Reliability**
- **Scalability**
- **Maintainability**
:::

## Reliability
:::{.callout-important icon=false}
## Kleppmann's definition
The system should continue to work correctly (performing the correct function at the desired level of performance) even in the face of adversity

- hardware faults
- software faults
- and even human error
:::

## Reliability
:::{.callout-warning icon=false}
## Faults
Basically, theses are things that could go wrong.

Systems that can anticipate faults are called **fault-tolerant** or **resilient**.

Fault can be defined as one component of the system deviating from the spec.
:::

:::{.callout-important icon=false}
## Failures
Failures occur when system stops providing services to the user.
:::

**Faults** *might* degenerate into [**failures**]{style="color:red;"}.


## Reliability
:::{.callout-tip icon=false}
## Types of errors

- Hardware
- Software
- Human
:::

## Reliability
![](img/error_stats)
<!-- https://www.salvationdata.com/knowledge/8-most-common-reasons-for-data-loss/ -->

## Scalability
:::{.callout-note icon=false}
## Kleppmann
As the system grows (in data volume, traffic volume, or complexity), there should be reasonable ways of dealing with that growth.

In other words, **scalability** is a systemâ€™s ability to cope with increased load.
:::

::: aside
Note that scalability is a multi-dimensional term. When saying "system scales well", it's important to state exactly along which axis.
:::

## Scalability
:::{.callout-tip icon=false}
## What is **load**?
Load is described by **load parameters**. These might include:

- **data set size**
- **data write speed**
- **data read speed**
- **computational complexity**
- etc...
:::

## Scalability
:::{.callout-important icon=false}
## Performance
Increasing **load** affects **performance**. There are several meanings to this term:

- **throughput** -- time required to process a dataset of certain size
- **response time** -- time between sending a request and receiving a response
- **latency** -- duration of waiting for a request to be processed. Included in response time.

:::

::: aside
Performance might be more strictly defined by service level objectives (*SLOs*) and service level agreements (*SLAs*).
:::

## Scalability
:::{.callout-note icon=false}
## How to deal with load

- **vertical scaling** - scaling up
- **horizontal scaling** - scaling out
- **architectural changes**
:::

:::{.callout-tip icon=false}
## Elasticity
An approach to load handling whereby a system automatically adds resources in case of load increase, and can decrease resources if load decreases. 
:::

## Scalability
:::{.callout-tip icon=false}
## Common wisdom
- Keep your **database** on a **single node** (scale up) until scaling cost or high-availability requirements forces you to make it **[distributed]{style="color:blue;"}**.
- **Optimize code** so that it can run on a **single node**.
:::

## Maintainability
:::{.callout-tip icon=false}
## Kleppmann
Over time, many different people will work on the system

- engineering
- operations
- both maintaining current behavior and adapting the system to new use cases),

and they should all be able to work on it **productively**.
:::

## Maintainability
:::{.callout-note icon=false}
## Principles

- **Operability** -- make it easy for operations teams to keep the system running smoothly.
- **Simplicity** -- make it easy for new engineers to understand the system, by removing as much complexity as possible from the system.
- **Evolvability** -- Make it easy for engineers to make changes to the system in the future, adapting it for unanticipated use cases as requirements change. Also known as **extensibility**, **modifiability**, or **plasticity**.
:::

## Maintainability
:::{.callout-note icon=false}
## Operability

- Health monitoring
- Good deployment practices
- Configuration management
- Visibility into the internals of the system
- Knowledge preservation -- **documentation** **[(!)]{style="color:red;"}**.
- etc...
:::

## Maintainability
:::{.callout-important icon=false}
## Complexity symptoms

- Lots of hidden state
- Loose cohesion, tight coupling
- Bad naming (!)
- Unnecessary hacks
- etc...
:::

## Maintainability: Complexity
<!-- https://storage.googleapis.com/dzkocnicjyofie/loose-coupling-vs-tight-coupling-java.html -->
![](img/cohesion_coupling.jpg)

## Maintainability: Complexity
:::{.callout-tip icon=false}
## Types
- **incidental**
- **accidental**
:::

## Maintainability: Complexity

:::{.callout-tip icon=false}
## Incidental
> Easy things can be complex. There can be complex constructs that are succinctly described, familiar, available and easy to use. That is incidental complexity.

Rich Hickey talk "Simple made easy": [https://www.youtube.com/watch?v=SxdOUGdseq4](https://www.youtube.com/watch?v=SxdOUGdseq4)
:::

## Maintainability: complexity
**However**:  Complexity is often caused by

:::{.callout-important icon=false}
## Accidental complexity
Moseley and Marks define complexity as accidental if it is not inherent in the problem that the software solves (as seen by the users) but arises only from the implementation.
:::

:::{.callout-tip icon=false}
## How to remove?
By providing proper **abstractions**.
:::

## Maintainability: abstractions
:::{.callout-note}
## Definition (Ousterhout)
An abstraction is a simplified view of an entity, which omits unimportant details.

In modular programming, each module provides an abstraction in the
form of its **interface.**
:::

![](img/abstractions_modules.png)

## Maintainability: abstractions
:::{.callout-note}
## What can abstractions do?

- Hide implementation details
- Provide reusable building blocks
:::


## Maintainability
:::{.callout-tip icon=false}
## Evolvability
One needs to adapt their big data system to possible future requirements changes.

However, keep in mind the following:

- Inability to foresee exact nature of changes
- Need to strike the balance of flexibility and fitness for a particular task
:::

## Types of big data analytics
:::{.callout-important icon=false}
## Types

- Prescriptive
- Diagnostic
- Descriptive
- Predictive
:::

## Types: Prescriptive
:::{.callout-important icon=false}
## Prescriptive

- Forward looking
- Optimal decisions for future situations
:::

## Types: Diagnostic
:::{.callout-important icon=false}
## Diagnostic

- Backward looking
- Focused on causal relationships 
:::

## Types: Descriptive
:::{.callout-tip icon=false}
## Descriptive

- Backward looking
- Focused on descriptions and comparisons
:::

## Types: Descriptive
:::{.callout-note icon=false}
## Predictive

- Forward looking
- Focused on the prediction of future states, relationship, and patterns
:::

## Challenges

There are 2 main challenges associated with Big Data.

:::{.callout-important icon=false}
## Challenges

- how do we store and manage such a **huge volume of data** efficiently?
- how do we process and extract valuable information from the data within the given **time frame**? 
:::
