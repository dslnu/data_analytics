---
title: "Big Data: Speeding up computation"
author: 
  - name: MSDE
    affiliation: Lviv University
code-fold: false
execute:
  enabled: false
  cache: true
diagram:
  cache: true
  cache-dir: ./cache
  engine:
    tikz:
      execpath: lualatex
      additional-packages: |
        \usetikzlibrary{arrows.meta}
        \usetikzlibrary{positioning}
        \usetikzlibrary{decorations.pathreplacing}
filters:
  - diagram
format: 
  revealjs:
    preview-links: auto
    slide-number: true
    theme: default
    multiplex:
      url: 'https://mplex.vitv.ly'
      secret: '2d4a6a0813faf1661f94d48e13b2fa26'
      id: 'b12293bd1701495a597c4dcd6971058a006114ebcaa231beb4301c90e5615c34'
---

## Memory management

:::: {.columns}

::: {.column width="50%" background-color="lightgray"}
:::{.callout-important icon=false}
## Manual

- C/C++
- Pascal
- Forth
- Fortran
- Zig
:::
:::

::: {.column width="50%" background-color="lightgray"}

:::{.callout-note icon=false}
## Automatic

- Lisp
- Java
- Python
- Go
- Julia
:::
:::
::::

## Memory management

:::{.callout-important icon=false}
## Code

```python
import os
import gc
import psutil

proc = psutil.Process(os.getpid())
gc.collect()
initial_memory = proc.memory_info().rss

## Allocate memory by creating large lists
foo = ['abc' for _ in range(10**7)]
allocated_memory = proc.memory_info().rss

## Deallocate memory
del foo
gc.collect()
final_memory = proc.memory_info().rss
```
:::


## Memory management

:::{.callout-tip icon=false}
## Print memory statistics
```python
increase = lambda x2, x1: 100.0 * (x2 - x1) / initial_memory
print("Allocated Memory Increase: %0.2f%%" % increase(allocated_memory, initial_memory))
print("Memory After Deletion: %0.2f%%" % increase(final_memory, allocated_memory))

>>> Allocated Memory Increase: 23.35%
>>> Memory After Deletion: -10.78%
```
:::

## Memory management
<!-- https://realpython.com/python-memory-management -->
:::{.callout-note}
## Python internals

- pools
- blocks
- arenas
:::

::: aside
1. https://docs.python.org/3/c-api/memory.html
2. https://realpython.com/python-memory-management
:::


## Memory management
![](img/python_mem)
<!-- mage from: https://www.honeybadger.io/blog/memory-management-in-python/ -->

# Code execution

## Python Options

|Libraries|Low-level langs|Alt Python Impls|JIT|
|---|---|---|---|
|NumPy, <br/> SciPy | C,<br/> Rust,<br/> Cython,<br/> PyO3 | PyPy, <br/>Jython | Numba, <br/>PyPy|


::: aside
**Options above are not mutually exclusive!**
:::


## Interpreters
:::{.callout-tip icon=false}
## Wikipedia definition
An interpreter is a computer program that directly executes instructions written in a programming or scripting language, without requiring them previously to have been compiled into a machine language program.
:::

:::{.callout-note icon=false}
## Examples

- Python
- Ruby
- Lua
- Javascript
:::

## CPython
![](img/cpython_internals)

:::{.callout-note icon=false}
## Flow

- Read Python code
- Convert Python into bytecode
- Execute bytecode inside a VM
- VM converts bytecode to machine code
:::

## CPython
![](img/cpython_code)
![](img/cpython_bytecode)

## Compilers
:::{.callout-tip icon=false}
## Wikipedia definition
Source code is compiled - in this context, translated into machine code for better performance.
:::

:::{.callout-note icon=false}
## Examples

- C/C++
- Go
- Python (to intermediate VM code)
- Java
- Cython
:::

## Compilers
![](img/llvm)

## Cython
:::{.callout-important icon=false}
## Definition
Cython is an optimising static compiler for the Python programming language.

- converts Python code to C
- supports static type declarations
:::

## Cython
![](img/cython_flow)

## Cython
![](img/cython_speedup)

## Cython
:::{.callout-tip icon=false}
## Python code
    
![](img/cython_integratev1)
:::

## Cython
:::{.callout-tip icon=false}
## Annotated Python code
![](img/cython_integratev2)
:::

## Cython
:::{.callout-important icon=false}
## Cython code
![](img/cython_integratev3)
:::

## Parallel Cython
![](img/cython_parallel1)

## Parallel Cython
![](img/cython_parallel2)

## JIT
:::{.callout-tip icon=false}
## Wikipedia definition
A compilation (of computer code) during execution of a program (at run time) rather than before execution.
:::

:::{.callout-note icon=false}
## Features

- **warm-up time:** JIT causes a slight to noticeable delay in the initial execution of an application, due to the time taken to load and compile the input code. 
- **statistics collection:** performed by the system during runtime, shows how the program is actually running in the environment it is in; helps JIT to rearrange and recompile for optimum performance. 
- particularly suited for **dynamic** programming languages
:::

## JIT
:::{.callout-note icon=false}
## Examples

- HotSpot Java Virtual Machine
- LuaJIT
- Numba
- PyPy
:::

## Numba
![](img/numba_arch)

## Numba
:::{.callout-note icon=false}
## Description

- Numba translates Python byte-code to machine code immediately before execution to improve the execution speed. 
- For that we add a `@jit` decorator
- Works well for numeric operations, NumPy, and loops
:::

## Numba
:::{.callout-tip icon=false}
## Steps

- read the Python bytecode for a decorated function 
- combine it with information about the types of the input arguments to the function
- analyze and optimize the code 
- use the LLVM compiler library to generate a machine code version of the function, tailored to specific CPU capabilities.
:::

## Numba
:::{.callout-tip icon=false}
## Works great
![](img/numba_example1)
:::

## Numba
:::{.callout-important icon=false}
## Nope
![](img/numba_example2)
:::

## Numba
![](img/numba_reduction)

<!-- ## Numba -->
<!-- :::{.callout-important icon=false} -->
<!-- ## Sequential -->
<!-- ![](img/numba_sequential){height=400} -->
<!-- ::: -->

<!-- ## Numba -->
<!-- :::{.callout-note icon=false} -->
<!-- ## Parallel -->
<!-- ![](img/numba_parallel){height=400} -->
<!-- ::: -->

## Numpy
:::{.callout-important icon=false}
## Why so fast?

- Optimized C code
- Densely packed arrays
- Uses BLAS - Basic Linear Algebra Subroutines. 
:::

# Rust/PyO3 example

## Rust/PyO3 example
:::{.callout-note icon=false}
## Description
We show an example of a simple algebraic cipher that utilizes PyO3 bindings to speed up encoding/decoding.
:::

:::{.callout-tip icon=false}
## Cipher definition
The basic mechanism for encrypting a message using a shared secret key is called a cipher (or
encryption scheme)
:::


## Rust/PyO3 example
::: {.hidden}
\newcommand{\bb}[1]{\boldsymbol{#1}}
\newcommand{\bi}[1]{\textbf{\textit{{#1}}}}
:::

:::{.callout-tip icon=false}
## Definition
Encryption and decryption use the same secret key.
:::

:::{.callout-important icon=false}
## Examples

- AES
- Salsa20
- Twofish
- DES

:::

## Rust/PyO3 example

:::{.callout-tip icon=false}
## Types

- block ciphers
- stream ciphers
- hash functions
:::


## Rust/PyO3 example
:::{.callout-tip icon=false}
## Overview
$$
f: \mathcal{K}\times\mathcal{D} \rightarrow C
$$
where

- $\mathcal{K}$ is **key space**
- $\mathcal{D}$ is **domain** (or **message space**)
- $\mathcal{C}$ is **co-domain** (or **ciphertext space**)
:::

## Rust/PyO3 example
:::{.callout-tip icon=false}
## Shannon cipher
A **Shannon cipher** is a pair $\mathcal{E} = (E,D)$ of functions:

- The function $E$ (the **encryption function**) takes as input a **key** $k$ and **message** $m$ (also called **plaintext**) and produces as output a **ciphertext** $c):
$$
c = E(k,m)
$$

$c$ is the **encryption** of $m$ **under** $k$.

- The function $D$ (the **decryption function**) takes as input a key $k$ and ciphertext $c$, and produces a message $m$:
$$
m = D(k,c)
$$

$m$ is the **decryption** of $c$ **under** $k$.
:::


## Rust/PyO3 example
:::{.callout-tip icon=false}
## Correctness property
For all keys $k$ and messages $m$, we have
$$
D(k, E(k,m)) = m
$$
:::


## Rust/PyO3 example

:::{.callout-important icon=false}
## Parameters
Now we describe the cipher.

First, we define cipher *parameters*:

- An alphabet $A$ with size $L \equiv |A|$.
- A matrix $M$ with size $N \gg L$
- $\sigma_1, \sigma_2$ are some permutations $N \rightarrow N$ 
- $\phi$ is some bit sequence of length $P$: $\phi \in \{0,1\}^P$

A triple $(\sigma_1, \sigma_2, \phi)$  will be our **secret key**.

We define each symbol $z$ by a corresponding set of diagonals $D$ in the matrix $M$, so that $\forall (x,y) \in D: x - y = z (\mod L)$ (see Figure 1).
:::

## Rust/PyO3 example
![](img/matrix.png)


## Rust/PyO3 example
:::{.callout-tip icon=false}
## Encoder flow
Suppose we receive some text $T$ containing symbols to be encoded.

For each $t_i \in T$, obtain its numeric representation $z_i$.
$$
z_i \in [0,L)
$$
Then we map each $z_i$ to a pair of matrix coordinates $(x_i, y_i)$ such that:

1. First, we pick a random $x_i \in [0,N)$ (e.g., horizontal coordinate in a matrix)

2. Then, we randomly pick some $y_i \in [0,N)$ such that:
$$
x_i - y_i = z_i (\mod L)
$$
:::

## Rust/PyO3 example
:::{.callout-tip icon=false}
## Encoder flow
Having thus obtained a sequence $\{(x_i, y_i), \, i \in [0, |T|) \}$, we now apply
permutations $\sigma_k: [0,N) \rightarrow [0,N), \, k=1,2$:
$$
\text{ciphertext } (\xi,\eta) := (\sigma_j(x),\sigma_{j+1}(y))
$$
where
$$
\sigma_j = \begin{cases}
\sigma_1, \; \text{if}\; \phi_j=0,\\
\sigma_2\; \text{otherwise}
\end{cases}
$$
:::

## Rust/PyO3 example
:::{.callout-note icon=false}
## Decoder flow
Below are steps executing during decoding phase:


1. Receive encoded ciphertext $\{(\xi_i, \eta_i)\}$.

2. Apply inverse permutations $\sigma_j^{-1}, \sigma_{j+1}^{-1}$:
$$
(x_i,y_i) = (\sigma_j^{-1}(\xi_i), \sigma_{j+1}^{-1}(\eta_i))
$$

3. Find $z_i$:
$$
z_i = x_i - y_i \; (\mod L)
$$
:::

## Rust/PyO3 example

:::{.callout-note icon=false}
## Implementation: PyO3

- Rust bindings for Python extension modules
:::

:::{.callout-tip icon=false}
## Users
- Qiskit <https://www.ibm.com/quantum/qiskit>
- Python Cryptography package <https://github.com/pyca/cryptography>
- Scallop <https://www.scallop-lang.org>
- HuggingFace Tokenizers <https://github.com/huggingface/tokenizers>
:::

## Rust/PyO3 example

:::{.callout-note icon=false}
## Rust wrapper
```rust
/// A Python module implemented in Rust.
#[pymodule]
fn cipher(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(encode, m)?)?;
    m.add_function(wrap_pyfunction!(decode, m)?)?;
    Ok(())
}
```
:::

## Rust/PyO3 example

:::{.callout-important icon=false}
## Encoding
```rust
// Generate random permutation of N integers
let mut numbers: Vec<usize> = (0..N).collect();
let mut rng = thread_rng();
numbers.shuffle(&mut rng);
let permutation = numbers;

// Generate pairs for each z
let mut pairs = Vec::with_capacity(zs.len());
for &z in &zs {
    // Generate random x between 0 and N-1
    let x = rng.gen_range(0..N);

    // Compute y such that x - y = z (mod L)
    let y = if x >= z {
        (x - z) % L
    } else {
        ((x + L) - z) % L
    };

    // Apply permutation to x and y
    let px = permutation[x];
    let py = permutation[y];
    pairs.push((px, py));
```
:::

## Rust/PyO3 example

:::{.callout-important icon=false}
## Decoding
```rust
// Create inverse permutation
let mut inverse = vec![0; N];
for (i, &p) in permutation.iter().enumerate() {
    inverse[p] = i;
}

// Recover z for each pair
let mut zs = Vec::with_capacity(pairs.len());
for &(px, py) in pairs {
    // Apply inverse permutation to get x and y
    let x = inverse[px];
    let y = inverse[py];

    // Compute z = x - y (mod L)
    let z = if x >= y {
        (x - y) % L
    } else {
        ((x + L) - y) % L
    };
    zs.push(z);
}
```
:::

## Rust/PyO3 example
:::{.callout-tip icon=false}
## Python
```python
mkdir cipher; cd cipher
python -m venv venv
. venv/bin/activate
!pip install maturin
maturin init
maturin develop
```
:::

:::{.callout-note icon=false}
## Usage
```python
import cipher
encoded = cipher.encode("Whazzuuupppp??!!")
decoded = cipher.decode(encoded)
```
:::

# Distributed computing
## Distributed computing
:::{.callout-note icon=false}
## Types

- **Cluster computing:** collection of similar workstations
- **Grid computing**: federation of different computer systems
- **Cloud computing:** provide the facilities to dynamically construct an infrastructure and compose what is needed from available services. Not only providing lots of resources.
:::

## Distributed computing
:::{.callout-tip icon=false}
## Original Beowulf cluster at NASA (1994)
![](img/beowulf.jpg){height=500}
:::

## Distributed computing
:::{.callout-important icon=false}
## Beowulf cluster diagram
![](img/beowulf_diagram)
:::

## Distributed computing
:::: {.columns}

::: {.column width="50%" background-color="lightgray"}

:::{.callout-note icon=false}
## Grid architecture diagram (Foster et al. 2001)
![](img/grid_arch_diagram)
:::

:::

::: {.column width="50%" background-color="lightgray"}

:::{.callout-tip icon=false}
## Notation
<div style="font-size: 0.8em;">
- **fabric:** interfaces to local resources at a specific site
- **connectivity**: communication protocols for supporting grid transactions that span the usage of multiple resources
- **resource:** responsible for managing a single resource
- **collective:** handling access to multiple resources and typically consists of services for resource discovery, allocation and scheduling of tasks onto multiple resources, data replication, and so on
- **application:** applications that operate within a virtual organization 
</div>
:::
:::
::::

## Distributed computing
:::{.callout-important icon=false}
## Cloud architecture
![](img/cloud_arch)
:::

