<!DOCTYPE html>
<html lang="en"><head>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/tabby.min.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.8.25">

  <meta name="author" content="MSDE">
  <title>Big Data analytics / Applied Data analytics – Big Data: GeoScience part 2</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="site_libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="site_libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; font-weight: bold; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="site_libs/revealjs/dist/theme/quarto-534cd8e3a96973385dffff3f4709048d.css">
  <link rel="stylesheet" href="custom.css">
  <link href="site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="site_libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="site_libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="site_libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>
  
  <script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">Big Data: GeoScience part 2</h1>

<div class="quarto-title-authors">
<div class="quarto-title-author">
<div class="quarto-title-author-name">
MSDE 
</div>
        <p class="quarto-title-affiliation">
            Lviv University
          </p>
    </div>
</div>

</section>
<section id="spatial-relationships" class="slide level2">
<h2>Spatial relationships</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Overview</strong></p>
</div>
<div class="callout-content">
<p>When working with geospatial data, you often need to do specific GIS operations based on how the data layers are located in relation to each other. For instance, finding out if a certain point is located inside an area, or whether a line intersects with another line or a polygon, are very common operations for selecting data based on spatial location.</p>
<ul>
<li>These kind of queries are commonly called as <em>{term}<code>spatial queries</code></em>.</li>
<li>Spatial queries are conducted based on the <em>{term}<code>topological spatial relations</code></em> which are fundamental constructs that describe how two or more geometric objects relate to each other concerning their position and boundaries.
<ul>
<li><em>contains</em></li>
<li><em>touches</em></li>
<li><em>intersects</em></li>
</ul></li>
</ul>
</div>
</div>
</div>
</section>
<section id="topological-spatial-relations" class="slide level2">
<h2>Topological spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>DE-9IM</strong></p>
</div>
<div class="callout-content">
<p>Computationally, conducting queries based on topological spatial relations, such as detecting if a point is inside a polygon can be done in different ways, but most GIS software rely on something called <em>{term}<code>Dimensionally Extended 9-Intersection Model</code></em> (<a href="https://en.wikipedia.org/wiki/DE-9IM">DE-9IM</a> [^DE-9IM]). DE-9IM is an ISO and OGC approved standard and a fundamental framework in GIS that is used to describe and analyze spatial relationships between geometric objects ({cite}<code>Clementini_1993</code>). DE-9IM defines the topological relations based on the interior, boundary, and exterior of two geometric shapes and how they intersect with each other (see Figure 6.34 and Figure 6.35). When doing this, the DE-9IM also considers the dimensionality of the objects. Considering the dimensionality of geometric objects is important because it determines the nature of spatial relations, influences the complexity of interactions between objects, and defines topological rules. Typically the more dimensions the geometric object has, the more complex the geometry: The <code>Point</code> objects are 0-dimensional, <code>LineString</code> and <code>LinearRing</code> are 1-dimensional and <code>Polygon</code> objects are 2-dimensional (see Figure 6.35).</p>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="img/DE-9IM_topology_interior_boundary_exterior.png"></p>
<figcaption><em><strong>Figure 6.35</strong>. Interior, boundary and exterior for different geometric data types. The data types can be either 0, 1 or 2-dimensional.</em></figcaption>
</figure>
</div>
</div>
</div>
</div>
</section>
<section id="topological-spatial-relations-1" class="slide level2">
<h2>Topological spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>DE-9IM</strong></p>
</div>
<div class="callout-content">
<p>When testing how two geometries relate to each other, the DE-9IM model gives a result which is called <em><code>spatial predicate</code></em> (also called as <em><code>binary predicate</code>)</em>. Figure 6.36 shows eight common spatial predicates based on the spatial relationship between the geometries ({cite}<code>Egenhofer_1992</code>). Many of these predicates, such as <em>intersects</em>, <em>within</em>, <em>contains</em>, <em>overlaps</em> and <em>touches</em> are commonly used when selecting data for specific area of interest or when joining data from one dataset to another based on the spatial relation between the layers. There are plenty of more topological relations: altogether 512 with 2D data. <img data-src="img/spatial-relations.png" alt="Figure 6.36. Eight common spatial predicates formed based on spatial relations between two geometries. Modified after Egenhofer et al.&nbsp;(1992)."></p>
</div>
</div>
</div>
</section>
<section id="topological-spatial-relations-2" class="slide level2">
<h2>Topological spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Types</strong></p>
</div>
<div class="callout-content">
<ul>
<li>When the geometries have at least one point in common, the geometries are said to be <em>intersecting</em> with each other.</li>
<li>When two geometries <em>touch</em> each other, they have at least one point in common (at the border in this case), but their interiors do not intersect with each other.</li>
<li>When the interiors of the geometries A and B are partially on top of each other and partially outside of each other, the geometries are <em>overlapping</em> with each other.</li>
<li>The spatial predicate for <em>covers</em> is when the interior of geometry B is almost totally within A, but they share at least one common coordinate at the border.</li>
<li>Similarly, if geometry A is almost totally contained by the geometry B (except at least one common coordinate at the border) the spatial predicate is called <em>covered by</em>.</li>
</ul>
</div>
</div>
</div>
</section>
<section id="topological-spatial-relations-3" class="slide level2">
<h2>Topological spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Making spatial queries in Python</strong></p>
</div>
<div class="callout-content">
<p>In Python, all the basic spatial predicates are available from <code>shapely</code> library, including:</p>
<ul>
<li><code>.intersects()</code></li>
<li><code>.within()</code></li>
<li><code>.contains()</code></li>
<li><code>.overlaps()</code></li>
<li><code>.touches()</code></li>
<li><code>.covers()</code></li>
<li><code>.covered_by()</code></li>
<li><code>.equals()</code></li>
<li><code>.disjoint()</code></li>
<li><code>.crosses()</code></li>
</ul>
</div>
</div>
</div>
</section>
<section id="topological-spatial-relations-4" class="slide level2">
<h2>Topological spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Making spatial queries in Python</strong></p>
</div>
<div class="callout-content">
<p>When you want to use Python to find out how two geometric objects are related to each other topologically, you start by creating the geometries using <code>shapely</code> library. In the following, we create a couple of <code>Point</code> objects and one <code>Polygon</code> object which we can use to test how they relate to each other:</p>
<div id="e887d7dd" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a></a><span class="im">from</span> shapely <span class="im">import</span> Point, Polygon</span>
<span id="cb1-2"><a></a></span>
<span id="cb1-3"><a></a><span class="co"># Create Point objects</span></span>
<span id="cb1-4"><a></a>point1 <span class="op">=</span> Point(<span class="fl">24.952242</span>, <span class="fl">60.1696017</span>)</span>
<span id="cb1-5"><a></a>point2 <span class="op">=</span> Point(<span class="fl">24.976567</span>, <span class="fl">60.1612500</span>)</span>
<span id="cb1-6"><a></a></span>
<span id="cb1-7"><a></a><span class="co"># Create a Polygon</span></span>
<span id="cb1-8"><a></a>coordinates <span class="op">=</span> [</span>
<span id="cb1-9"><a></a>    (<span class="fl">24.950899</span>, <span class="fl">60.169158</span>),</span>
<span id="cb1-10"><a></a>    (<span class="fl">24.953492</span>, <span class="fl">60.169158</span>),</span>
<span id="cb1-11"><a></a>    (<span class="fl">24.953510</span>, <span class="fl">60.170104</span>),</span>
<span id="cb1-12"><a></a>    (<span class="fl">24.950958</span>, <span class="fl">60.169990</span>),</span>
<span id="cb1-13"><a></a>]</span>
<span id="cb1-14"><a></a>polygon <span class="op">=</span> Polygon(coordinates)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</div>
</div>
</div>
</section>
<section id="topological-spatial-relations-5" class="slide level2">
<h2>Topological spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Making spatial queries in Python</strong></p>
</div>
<div class="callout-content">
<p>We can check the contents of the new variables by printing them to the screen, for example, in which case we would see</p>
<div id="66fc05fa" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a></a><span class="bu">print</span>(point1)</span>
<span id="cb2-2"><a></a><span class="bu">print</span>(point2)</span>
<span id="cb2-3"><a></a><span class="bu">print</span>(polygon)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>POINT (24.952242 60.1696017)
POINT (24.976567 60.16125)
POLYGON ((24.950899 60.169158, 24.953492 60.169158, 24.95351 60.170104, 24.950958 60.16999, 24.950899 60.169158))</code></pre>
</div>
</div>
<p>If you want to test whether these <code>Point</code> geometries stored in <code>point1</code> and <code>point2</code> are within the <code>polygon</code>, you can call the <code>.within()</code> method as follows:</p>
<div id="eaed302e" class="cell" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a></a>point1.within(polygon)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="104">
<pre><code>True</code></pre>
</div>
</div>
<div id="19428104" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a></a>point2.within(polygon)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="105">
<pre><code>False</code></pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="topological-spatial-relations-6" class="slide level2 scrollable">
<h2>Topological spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Making spatial queries in Python</strong></p>
</div>
<div class="callout-content">
<p>One of the most common spatial queries is to see if a geometry intersects or touches another one. Again, there are binary operations in <code>shapely</code> for checking these spatial relationships:</p>
<ul>
<li><code>.intersects()</code> - Two objects intersect if the boundary or interior of one object intersect in any way with the boundary or interior of the other object.</li>
<li><code>.touches()</code> - Two objects touch if the objects have at least one point in common and their interiors do not intersect with any part of the other object.</li>
</ul>
<p>Let’s try these by creating two <code>LineString</code> geometries and test whether they intersect and touch each other:</p>
<div id="1100dfe9" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a></a><span class="im">from</span> shapely <span class="im">import</span> LineString, MultiLineString</span>
<span id="cb8-2"><a></a></span>
<span id="cb8-3"><a></a><span class="co"># Create two lines</span></span>
<span id="cb8-4"><a></a>line_a <span class="op">=</span> LineString([(<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">1</span>)])</span>
<span id="cb8-5"><a></a>line_b <span class="op">=</span> LineString([(<span class="dv">1</span>, <span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">2</span>)])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="6d864fd2" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a></a>line_a.intersects(line_b)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="107">
<pre><code>True</code></pre>
</div>
</div>
<div id="851e6d2f" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a></a>line_a.touches(line_b)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="108">
<pre><code>True</code></pre>
</div>
</div>
<p>As we can see, it seems that our two <code>LineString</code> objects are both intersecting and touching each other. We can confirm this by plotting the features together as a <code>MultiLineString</code>: <!-- #endregion --></p>
<div id="1cf559cb" class="cell" data-execution_count="9">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a></a><span class="co"># Create a MultiLineString from line_a and line_b</span></span>
<span id="cb13-2"><a></a>multi_line <span class="op">=</span> MultiLineString([line_a, line_b])</span>
<span id="cb13-3"><a></a>multi_line</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="109">
<div>
<figure>
<p><img data-src="bigdata_lec8_part2_files/figure-revealjs/cell-9-output-1.svg"></p>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="topological-spatial-relations-7" class="slide level2 scrollable">
<h2>Topological spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Making spatial queries in Python</strong></p>
</div>
<div class="callout-content">
<p>However, if the lines are fully overlapping with each other they don’t touch due to the spatial relationship rule in the DE-9IM. We can confirm this by checking if <code>line_a</code> touches itself:</p>
<div id="7d73d847" class="cell" data-execution_count="10">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a></a>line_a.touches(line_a)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="110">
<pre><code>False</code></pre>
</div>
</div>
<p>No it doesn’t. However, <code>.intersects()</code> and <code>.equals()</code> should produce <code>True</code> for a case when we compare the <code>line_a</code> with itself:</p>
<div id="96118526" class="cell" data-execution_count="11">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a></a><span class="bu">print</span>(<span class="st">"Intersects?"</span>, line_a.intersects(line_a))</span>
<span id="cb16-2"><a></a><span class="bu">print</span>(<span class="st">"Equals?"</span>, line_a.equals(line_a))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Intersects? True
Equals? True</code></pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="topological-spatial-relations-8" class="slide level2">
<h2>Topological spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Exercise</strong></p>
</div>
<div class="callout-content">
<p>Use python to prove that <code>line_a</code> and <code>line_b</code> are not identical.</p>
<!--
```python editable=true slideshow={"slide_type": ""} tags=["remove_book_cell", "hide-cell"]
# Solution

print("Line a is equal to line b: ", line_a.equals(line_b))
```
-->
</div>
</div>
</div>
</section>
<section id="topological-spatial-relations-9" class="slide level2 scrollable">
<h2>Topological spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Making spatial queries in Python</strong></p>
</div>
<div class="callout-content">
<p>Following the syntax from the previous examples, we can test all different spatial predicates and assess the spatial relationship between geometries. The following prints results for all predicates between the <code>point1</code> and the <code>polygon</code> which we created earlier:</p>
<div id="2045f4e0" class="cell" data-execution_count="12">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a></a><span class="bu">print</span>(<span class="st">"Intersects?"</span>, point1.intersects(polygon))</span>
<span id="cb18-2"><a></a><span class="bu">print</span>(<span class="st">"Within?"</span>, point1.within(polygon))</span>
<span id="cb18-3"><a></a><span class="bu">print</span>(<span class="st">"Contains?"</span>, point1.contains(polygon))</span>
<span id="cb18-4"><a></a><span class="bu">print</span>(<span class="st">"Overlaps?"</span>, point1.overlaps(polygon))</span>
<span id="cb18-5"><a></a><span class="bu">print</span>(<span class="st">"Touches?"</span>, point1.touches(polygon))</span>
<span id="cb18-6"><a></a><span class="bu">print</span>(<span class="st">"Covers?"</span>, point1.covers(polygon))</span>
<span id="cb18-7"><a></a><span class="bu">print</span>(<span class="st">"Covered by?"</span>, point1.covered_by(polygon))</span>
<span id="cb18-8"><a></a><span class="bu">print</span>(<span class="st">"Equals?"</span>, point1.equals(polygon))</span>
<span id="cb18-9"><a></a><span class="bu">print</span>(<span class="st">"Disjoint?"</span>, point1.disjoint(polygon))</span>
<span id="cb18-10"><a></a><span class="bu">print</span>(<span class="st">"Crosses?"</span>, point1.crosses(polygon))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Intersects? True
Within? True
Contains? False
Overlaps? False
Touches? False
Covers? False
Covered by? True
Equals? False
Disjoint? False
Crosses? False</code></pre>
</div>
</div>
<p>Looking at all the spatial predicates, we can see that the spatial relationship between our point and polygon object produces three <code>True</code> values: The point and polygon intersect with each other, the point is within the polygon, and the point is covered by the polygon. All the other tests correctly produce <code>False</code>, which matches with the logic of the <code>DE-9IM</code> standard.</p>
</div>
</div>
</div>
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong><code>within</code> vs <code>contains</code></strong></p>
</div>
<div class="callout-content">
<ul>
<li>if you have many points and just one polygon and you try to find out which one of them is inside the polygon: You might need to check the separately for each point to see which one is <code>.within()</code> the polygon.</li>
<li>if you have many polygons and just one point and you want to find out which polygon contains the point: You might need to check separately for each polygon to see which one(s) <code>.contains()</code> the point.</li>
</ul>
</div>
</div>
</div>
</section>
<section id="spatial-relations" class="slide level2">
<h2>Spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Spatial queries using geopandas</strong></p>
</div>
<div class="callout-content">
<div id="40d8b7ce" class="cell" data-execution_count="13">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb20-2"><a></a></span>
<span id="cb20-3"><a></a>points <span class="op">=</span> gpd.read_file(<span class="st">"_data/Helsinki/addresses.shp"</span>)</span>
<span id="cb20-4"><a></a>districts <span class="op">=</span> gpd.read_file(<span class="st">"_data/Helsinki/Major_districts.gpkg"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="16d1d156" class="cell" data-execution_count="14">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a></a><span class="bu">print</span>(<span class="st">"Shape:"</span>, points.shape)</span>
<span id="cb21-2"><a></a><span class="bu">print</span>(points.head())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Shape: (34, 1)
                    geometry
0   POINT (24.91556 60.1632)
1  POINT (24.93166 60.16905)
2  POINT (24.94168 60.16996)
3  POINT (24.97865 60.19005)
4  POINT (24.92151 60.15662)</code></pre>
</div>
</div>
<div id="f335fd7f" class="cell" data-execution_count="15">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a></a><span class="bu">print</span>(<span class="st">"Shape:"</span>, districts.shape)</span>
<span id="cb23-2"><a></a><span class="bu">print</span>(districts.tail(<span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Shape: (23, 3)
           Name Description                                           geometry
18    Koivukylä              POLYGON Z ((24.99423 60.33296 0, 25.00007 60.3...
19      Itäinen              POLYGON Z ((25.03517 60.23627 0, 25.03585 60.2...
20  Östersundom              POLYGON Z ((25.23352 60.25655 0, 25.23744 60.2...
21     Hakunila              POLYGON Z ((25.08472 60.27248 0, 25.08492 60.2...
22        Korso              POLYGON Z ((25.1238 60.34191 0, 25.11997 60.34...</code></pre>
</div>
</div>
<p>The data contains 34 address points and 23 district polygons.</p>
</div>
</div>
</div>
</section>
<section id="spatial-relations-1" class="slide level2 scrollable">
<h2>Spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Spatial queries using geopandas</strong></p>
</div>
<div class="callout-content">
<p>For demonstration purposes, we are interested in finding all points that are within two areas in Helsinki region, namely <code>Itäinen</code> and <code>Eteläinen</code> (<em>‘Eastern’</em> and <em>‘Southern’</em> in English). Let’s first select the districts using the <code>.loc</code> indexer and the listed criteria which we can use with the <code>.isin()</code> method to filter the data, as we learned already in Chapter 3:</p>
<div id="1d2cdc33" class="cell" data-execution_count="16">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a></a>selection <span class="op">=</span> districts.loc[districts[<span class="st">"Name"</span>].isin([<span class="st">"Itäinen"</span>, <span class="st">"Eteläinen"</span>])]</span>
<span id="cb25-2"><a></a><span class="bu">print</span>(selection.head())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>         Name Description                                           geometry
10  Eteläinen              POLYGON Z ((24.78277 60.09997 0, 24.81973 60.1...
19    Itäinen              POLYGON Z ((25.03517 60.23627 0, 25.03585 60.2...</code></pre>
</div>
</div>
<p>Let’s now plot the layers on top of each other. The areas with red color represent the districts that we want to use for testing the spatial relationships against the point layer (shown with blue color):</p>
<div id="3640a3a2" class="cell" data-execution_count="17">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a></a>base <span class="op">=</span> districts.plot(facecolor<span class="op">=</span><span class="st">"gray"</span>)</span>
<span id="cb27-2"><a></a>selection.plot(ax<span class="op">=</span>base, facecolor<span class="op">=</span><span class="st">"red"</span>)</span>
<span id="cb27-3"><a></a>points.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">"blue"</span>, markersize<span class="op">=</span><span class="dv">5</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="bigdata_lec8_part2_files/figure-revealjs/cell-17-output-1.png" width="617" height="411"></p>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="spatial-relations-2" class="slide level2 scrollable">
<h2>Spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Spatial queries using geopandas</strong></p>
</div>
<div class="callout-content">
<p>As we can see from Figure 6.37, many points seem to be within the two selected districts. To find out which of of them are located within the Polygon, we need to conduct a Point in Polygon -query. We can do this by checking which Points in the <code>points</code> GeoDataFrame are <em>within</em> the selected polygons stored in the <code>selection</code> geodataframe. In the following, we will show how to take advantage of a method called <code>.sjoin()</code> for doing spatial queries between two GeoDataFrames. Normally, <code>.sjoin()</code> method is used for conducting a <em>{term}<code>spatial join</code></em> between two spatial datasets, meaning that specific attribute information from a given GeoDataFrame is joined to the other one based on their topological relationship (see Chapter 6.7 for more details). However, spatial join can also be used as an efficient way to conduct spatial queries in <code>geopandas</code>. Consider the following example in which we use the <code>.sjoin()</code> method using <code>"within"</code> as the <code>predicate</code> parameter to select all points that are within the selected polygons: <!-- #endregion --></p>
<div id="2a344e3e" class="cell" data-execution_count="18">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a></a>selected_points <span class="op">=</span> points.sjoin(selection.geometry.to_frame(), predicate<span class="op">=</span><span class="st">"within"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="4dee7817" class="cell" data-execution_count="19">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a></a>ax <span class="op">=</span> districts.plot(facecolor<span class="op">=</span><span class="st">"gray"</span>)</span>
<span id="cb29-2"><a></a>ax <span class="op">=</span> selection.plot(ax<span class="op">=</span>ax, facecolor<span class="op">=</span><span class="st">"red"</span>)</span>
<span id="cb29-3"><a></a>ax <span class="op">=</span> selected_points.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">"gold"</span>, markersize<span class="op">=</span><span class="dv">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="bigdata_lec8_part2_files/figure-revealjs/cell-19-output-1.png" width="617" height="411"></p>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="spatial-relations-3" class="slide level2 scrollable">
<h2>Spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Spatial queries using geopandas</strong></p>
</div>
<div class="callout-content">
<p>As a result, we have now selected only the (golden) points that are inside the red polygons which is exactly what we wanted. Notice how we used the <code>selection.geometry.to_frame()</code> when calling the <code>.sjoin()</code> method. This is a special trick to avoid attaching any extra attributes from the <code>selection</code> geodataframe to our data, which is what <code>.sjoin()</code> method would normally do (and which it is actually designed for). As we are only interested in the geometries of the right-hand-side layer to do the selection, calling the <code>.geometry.to_frame()</code> will first select the geometry column from the <code>selection</code> layer and then converts it into a <code>GeoDataFrame</code> (which would otherwise be a GeoSeries). An alternative approach for doing the same thing is to use <code>selection[[selection.active_geometry_name]]</code>, which also returns a <code>GeoDataFrame</code> containing only a column with the geodataframe’s active geometry.</p>
<p>In a similar manner, we can easily use the <code>.sjoin()</code> with other predicates to make selections based on how the geometries between two GeoDataFrames are related to each other. By default, the <code>.sjoin()</code> uses <code>"intersects"</code> as a spatial predicate, but it is easy to change this. For example, we can investigate which of the districts <em>contain</em> at least one point. In this case, we make a spatial join using the <code>disctricts</code> GeoDataFrame as a starting point, join the layer with the <code>points</code> and use the <code>"contains"</code> as a value to our <code>predicate</code> parameter: <!-- #endregion --></p>
<div id="698d029b" class="cell" data-execution_count="20">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a></a>districts_with_points <span class="op">=</span> districts.sjoin(</span>
<span id="cb30-2"><a></a>    points.geometry.to_frame(), predicate<span class="op">=</span><span class="st">"contains"</span></span>
<span id="cb30-3"><a></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="54c54703" class="cell" data-execution_count="21">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a></a>ax <span class="op">=</span> districts.plot(facecolor<span class="op">=</span><span class="st">"gray"</span>)</span>
<span id="cb31-2"><a></a>ax <span class="op">=</span> districts_with_points.plot(ax<span class="op">=</span>ax, edgecolor<span class="op">=</span><span class="st">"gray"</span>)</span>
<span id="cb31-3"><a></a>ax <span class="op">=</span> points.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">"red"</span>, markersize<span class="op">=</span><span class="dv">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="bigdata_lec8_part2_files/figure-revealjs/cell-21-output-1.png" width="617" height="411"></p>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="spatial-relations-4" class="slide level2 scrollable">
<h2>Spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Spatial queries using geopandas</strong></p>
</div>
<div class="callout-content">
<p>As a result, we can now see that all the polygons marked with blue color were correctly selected as the ones which contain at least one point object. One important thing to remember whenever making spatial queries is that both layers need to share the same Coordinate Reference System for the selection to work properly. A typical reason for getting incorrect results when selecting data (likely an empty GeoDataFrame) is that one data layer is e.g.&nbsp;in WGS84 coordinate reference system whereas the other one is in some projected CRS, such as ETRS-LAEA. If this happens, you can easily fix the situation by defining and reprojecting both GeoDataFrames to same CRS using the <code>.to_crs()</code> method (see Chapter 6.4).</p>
<p>Following the previous examples, you can easily test other topological relationships as well, by changing the value in <code>predicate</code> parameter. To find all possible spatial predicates for a given GeoDataFrame you can call:</p>
<div id="a88afcfd" class="cell" data-execution_count="22">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a></a>districts.sindex.valid_query_predicates</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="122">
<pre><code>{None,
 'contains',
 'contains_properly',
 'covered_by',
 'covers',
 'crosses',
 'dwithin',
 'intersects',
 'overlaps',
 'touches',
 'within'}</code></pre>
</div>
</div>
<p>As you can see, this list includes all typical spatial predicates which we covered earlier. But what is this <code>.sindex</code> that we use here? Let’s investigate it a bit further:</p>
<div id="62011fcf" class="cell" data-execution_count="23">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a></a>districts.sindex</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="123">
<pre><code>&lt;geopandas.sindex.SpatialIndex at 0x112d7edd0&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="spatial-relations-5" class="slide level2 scrollable">
<h2>Spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Spatial queries using geopandas</strong></p>
</div>
<div class="callout-content">
<p>As we can see, the <code>.sindex</code> is something called <code>SpatialIndex</code> object. This is something that <code>geopandas</code> prepares automatically for <code>GeoDataFrames</code> and as the name implies, it contains the <em>{term}<code>spatial index</code></em> for our data. A spatial index is a special data structure that allows for efficient querying of spatial data. There are many different kind of spatial indices, but <code>geopandas</code> uses a spatial index called R-tree which is a hierarchical, tree-like structure that divides the space into nested, overlapping rectangles and indexes the bounding boxes of each geometry. The spatial index improves the performance of spatial queries, such as finding all objects that intersect with a given area. The <code>.sjoin()</code> method takes advantage of the spatial index and is therefore an extremely powerful and makes the queries faster (see Appendix 5 for further details). This comes very practical especially when working with large datasets and doing e.g.&nbsp;a point-in-polygon type of queries with millions of point observations. Hence, when selecting data based on topological relations, we recommend using <code>.sjoin()</code> instead of directly calling <code>.within()</code>, <code>.contains()</code> that come with the <code>shapely</code> geometries (as shown previously).</p>
</div>
</div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} tags=["question"] -->
</section>
<section id="spatial-relations-6" class="slide level2">
<h2>Spatial relations</h2>
<div class="callout callout-tip no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Exercise</strong></p>
</div>
<div class="callout-content">
<p>How many addresses are located in each district? You can find out the answer by grouping the spatial join result based the district name (see Part I, chapter 3 for a reminder on how to group and aggregate data).</p>
<!--
```python editable=true slideshow={"slide_type": ""} tags=["remove_book_cell", "hide-cell"]
# Solution

# Check column names in the spatial join result
print(districts_with_points.columns.values)

# Group by district name
grouped = districts_with_points.groupby("Name")

# Count the number of rows (adress locations) in each district
grouped.index_right.count()
```
-->
</div>
</div>
</div>
</section>
<section id="spatial-join" class="slide level2 scrollable">
<h2>Spatial join</h2>
<div class="callout callout-note no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Description</strong></p>
</div>
<div class="callout-content">
<p>Spatial join is yet another classic GIS task. Retrieving table attributes from one layer and transferring them into another layer based on their spatial relationship is something you most likely need to do on a regular basis when working with geographic data. In the previous section, you learned how to perform spatial queries, such as investigating if a Point is located within a Polygon. We can use this same logic to conduct a spatial join between two layers based on their spatial relationship and transfer the information stored in one layer into the other. We could, for example, join the attributes of a polygon layer into a point layer where each point would get the attributes of a polygon that <code>intersects</code> with the point.</p>
<p>In Figure 6.41, we illustrate the logic of a spatial join by showing how it is possible to combine information between spatial data layers that are located in the same area (i.e.&nbsp;they overlap with each other at least partially). The target here is to combine attribute information of three layers: properties, land use and buildings. Each of these three layers has their own attribute information. Transfering the information between the layers is based on how the individual points in the Properties layer intersect with these layers as shown on the left, i.e.&nbsp;considering different land use areas (commercial, residential, industrial, natural), as well as the building footprints containing a variety of building-related attibute information. On the right, we show the table attributes for these three layers considering the features that intersect with the four Point observations. The table at the bottom shows how the results look after all the attribute data from these layers has been combined into a single table.</p>
<p>It is good to remember that spatial join is always conducted between two layers at a time. Hence, in practice, if we want to make a spatial join between these three layers shown in Figure 6.41, we first need to conduct the spatial join between Properties and Land use, and then store this information into an intermediate result. After the first join, we need to make another spatial join between the intermediate result and the third layer (here, the Buildings dataset). After these two separate spatial joins, we have achieved the final result shown at the bottom, showing for each property (row) the corresponding attributes from the land use and building layers as separate columns. In a similar manner, you could also continue joining data (attributes) from other layers as long as you need.</p>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="img/spatial-join-basic-idea.png"></p>
<figcaption><em><strong>Figure 6.41</strong>. Spatial join allows you to combine attribute information from multiple layers based on spatial relationship.</em></figcaption>
</figure>
</div>
</div>
</div>
</div>
</section>
<section id="spatial-join-1" class="slide level2 scrollable">
<h2>Spatial join</h2>
<div class="callout callout-note no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>sjoin details</strong></p>
</div>
<div class="callout-content">
<p>Now as we understand the basic idea behind the spatial join, let’s continue to learn a bit more about the details of spatial join. Figure 6.42 illustrates how we can do a spatial join between Point and Polygon layers, and how changing specific parameters in the way the join is conducted influence the results. In spatial join, there are two set of options that you can control, which ultimately influence how the data is transferred between the layers. You can control:</p>
<ol type="1">
<li>How the spatial relationship between geometries should be checked (i.e.&nbsp;spatial predicates), and</li>
<li>What type of table join you want to conduct (inner, left, or right outer join)</li>
</ol>
<p>The spatial predicates control how the spatial relationship between the geometries in the two data layers is checked. Only those cases where the spatial predicate returns <code>True</code> will be kept in the result. Thus, changing this option (parameter) can have a big influence on your final results after the join. In Figure 6.41 this difference is illustrated at the bottom when you compare the result tables <em>i</em> and <em>ii</em>: In the first table (<em>i</em>) the spatial predicate is <code>within</code> that gives us 4 rows that is shown in the table. However, on the second result table (<em>ii</em>), the spatial predicate <code>intersects</code> gives us 5 rows. Why is there a difference? This is because the Point with id-number 6 happens to lie exactly at the border of the Polygon C. As you might remember from the Chapter 6.6, there is a certain difference between these two spatial predicates: The <code>within</code> predicate expects that the Point should be inside the Polygon (<code>False</code> in our case), whereas <code>intersects</code> returns <code>True</code> if at least one point is common between the geometries (<code>True</code> in our case). In a similar manner, you could change the spatial predicate to <code>contains</code>, <code>touches</code>, <code>overlaps</code> etc. and the result would change accordingly.</p>
<p>It is also important to ensure that the logic for investigating these spatial relationships makes sense when deciding which spatial predicate to use. For example, it would not make any sense to check whether Layer 1 (points) contain the Layer 2 (polygons) because Point objects do not have an interior or boundary, thus lacking the ability to contain any geometric object. Doing this kind of spatial join is possible, but the result from this type of spatial join would always return an empty <code>GeoDataFrame</code>. However, if we change the spatial join criteria and join the data between layers if the Layer 2 (polygons) contain the Layer 1 (points), this would make a perfect sense, and the query would return rows that match with this criteria.</p>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="img/spatial-join-alternatives.png"></p>
<figcaption><em><strong>Figure 6.42</strong>. Different approaches to join two data layers with each other based on spatial relationships.</em></figcaption>
</figure>
</div>
</div>
</div>
</div>
</section>
<section id="spatial-join-2" class="slide level2 scrollable">
<h2>Spatial join</h2>
<div class="callout callout-note no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>sjoin type</strong></p>
</div>
<div class="callout-content">
<p>The other parameter that you can use to control how the spatial join is conducted is the spatial join type. There are three different join types that influence the outcome of the spatial join:</p>
<ol type="1">
<li><code>inner join</code></li>
<li><code>left outer join</code></li>
<li><code>right outer join</code></li>
</ol>
</div>
</div>
</div>
</section>
<section id="spatial-join-3" class="slide level2 scrollable">
<h2>Spatial join</h2>
<div class="callout callout-note no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Spatial join with Python</strong></p>
</div>
<div class="callout-content">
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Now as we have learned the basic logic of spatial join, let’s see how we can do it in Python. Spatial join can be done easily with <code>geopandas</code> using the <code>.sjoin()</code> method. Next, we will learn how to use this method to perform a spatial join between two layers:</p>
<ol type="1">
<li><code>addresses</code> which are the locations that we geocoded previously;</li>
<li><code>population grid</code> which is a 250m x 250m grid polygon layer that contains population information from the Helsinki Region (source: Helsinki Region Environmental Services Authority). Let’s start by reading the data:</li>
</ol>
<div id="1f075849" class="cell" data-execution_count="24">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb36"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb36-2"><a></a></span>
<span id="cb36-3"><a></a>addr_fp <span class="op">=</span> <span class="st">"_data/Helsinki/addresses.shp"</span></span>
<span id="cb36-4"><a></a>addresses <span class="op">=</span> gpd.read_file(addr_fp)</span>
<span id="cb36-5"><a></a>addresses.head(<span class="dv">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="124">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe caption-top" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>POINT (24.91556 60.1632)</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>POINT (24.93166 60.16905)</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>As we can see, the <code>addresses</code> variable contains address Points which represent a selection of public transport stations in the Helsinki Region.</p>
</div>
</div>
</div>
</section>
<section id="spatial-join-4" class="slide level2 scrollable">
<h2>Spatial join</h2>
<div class="callout callout-note no-icon callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<p><strong>Spatial join with Python</strong></p>
</div>
<div class="callout-content">
<div id="adfd32f7" class="cell" data-execution_count="25">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a></a>pop_grid_fp <span class="op">=</span> <span class="st">"_data/Helsinki/Population_grid_2021_HSY.gpkg"</span></span>
<span id="cb37-2"><a></a>pop_grid <span class="op">=</span> gpd.read_file(pop_grid_fp)</span>
<span id="cb37-3"><a></a>pop_grid.head(<span class="dv">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="125">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe caption-top" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">inhabitants</th>
<th data-quarto-table-cell-role="th">occupancy_rate</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>Vaestotietoruudukko_2021.1</td>
<td>5</td>
<td>50.60</td>
<td>POLYGON ((25472499.995 6689749.005, 25472499.9...</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>Vaestotietoruudukko_2021.2</td>
<td>7</td>
<td>36.71</td>
<td>POLYGON ((25472499.995 6685998.998, 25472499.9...</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>The <code>pop_grid</code> dataset contains few columns, namely a unique <code>id</code>, the number of <code>inhabitants</code> per grid cell, and the <code>occupancy_rate</code> as percentage.</p>
</div>
</div>
</div>


</section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<div class="footer footer-default">

</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="site_libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="site_libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="site_libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="site_libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="site_libs/revealjs/plugin/multiplex/socket.io.js"></script>
  <script src="site_libs/revealjs/plugin/multiplex/multiplex.js"></script>
  <script src="site_libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="site_libs/revealjs/plugin/notes/notes.js"></script>
  <script src="site_libs/revealjs/plugin/search/search.js"></script>
  <script src="site_libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="site_libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': true,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'multiplex': {"url":"https://mplex.vitv.ly","secret":null,"id":"8c59ccb7e4dfa2211ed14fa17fb72b1b76d07c2cab789dac3e2fe06135105e8a"},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
          const outerScaffold = trigger.parentElement.cloneNode(true);
          const codeEl = outerScaffold.querySelector('code');
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp("https:\/\/dslnu\.github\.io\/data_analytics\/");
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>