---
title: "Big Data: GeoScience part 2"
author: 
  - name: MSDE
    affiliation: Lviv University
code-fold: false
execute:
  enabled: true
  cache: true
diagram:
  cache: true
  cache-dir: ./cache
  engine:
    tikz:
      execpath: lualatex
      additional-packages: |
        \usetikzlibrary{arrows.meta}
        \usetikzlibrary{positioning}
        \usetikzlibrary{decorations.pathreplacing}
filters:
  - diagram
format: 
  revealjs:
    css: custom.css
    preview-links: auto
    slide-number: true
    theme: default
    multiplex:
      url: 'https://mplex.vitv.ly'
      secret: 'a8ec82984651e86fa95bf7dc4a1b8de2'
      id: '8c59ccb7e4dfa2211ed14fa17fb72b1b76d07c2cab789dac3e2fe06135105e8a'
---


<!-- #region editable=true slideshow={"slide_type": ""} -->
# Selecting data based on spatial relationships

## Selecting data based on spatial relationships
:::{.callout-tip icon=false}
## Overview

When working with geospatial data, you often need to do specific GIS operations based on how the data layers are located in relation to each other. For instance, finding out if a certain point is located inside an area, or whether a line intersects with another line or a polygon, are very common operations for selecting data based on spatial location.

- These kind of queries are commonly called as *{term}`spatial queries`*.
- Spatial queries are conducted based on the *{term}`topological spatial relations`* which are fundamental constructs that describe how two or more geometric objects relate to each other concerning their position and boundaries. 
  - *contains*
  - *touches*
  - *intersects* 
:::

## Topological spatial relations
:::{.callout-tip icon=false}
## DE-9IM

Computationally, conducting queries based on topological spatial relations, such as detecting if a point is inside a polygon can be done in different ways, but most GIS software rely on something called *{term}`Dimensionally Extended 9-Intersection Model`* ([DE-9IM](https://en.wikipedia.org/wiki/DE-9IM) [^DE-9IM]). DE-9IM is an ISO and OGC approved standard and a fundamental framework in GIS that is used to describe and analyze spatial relationships between geometric objects ({cite}`Clementini_1993`). DE-9IM defines the topological relations based on the interior, boundary, and exterior of two geometric shapes and how they intersect with each other (see Figure 6.34 and Figure 6.35). When doing this, the DE-9IM also considers the dimensionality of the objects. Considering the dimensionality of geometric objects is important because it determines the nature of spatial relations, influences the complexity of interactions between objects, and defines topological rules. Typically the more dimensions the geometric object has, the more complex the geometry: The `Point` objects are 0-dimensional, `LineString` and `LinearRing` are 1-dimensional and `Polygon` objects are 2-dimensional (see Figure 6.35).   

![_**Figure 6.35**. Interior, boundary and exterior for different geometric data types. The data types can be either 0, 1 or 2-dimensional._](img/DE-9IM_topology_interior_boundary_exterior.png)
:::


## Topological spatial relations
:::{.callout-tip icon=false}
## DE-9IM
When testing how two geometries relate to each other, the DE-9IM model gives a result which is called *`spatial predicate`* (also called as *`binary predicate`)*. Figure 6.36 shows eight common spatial predicates based on the spatial relationship between the geometries ({cite}`Egenhofer_1992`). Many of these predicates, such as *intersects*, *within*, *contains*, *overlaps* and *touches* are commonly used when selecting data for specific area of interest or when joining data from one dataset to another based on the spatial relation between the layers. 
There are plenty of more topological relations: altogether 512 with 2D data.
![_**Figure 6.36**. Eight common spatial predicates formed based on spatial relations between two geometries. Modified after Egenhofer et al. (1992)_.](img/spatial-relations.png)
:::

## Topological spatial relations
:::{.callout-tip icon=false}
## Types
- When the geometries have at least one point in common, the geometries are said to be *intersecting* with each other.
- When two geometries *touch* each other, they have at least one point in common (at the border in this case), but their interiors do not intersect with each other.
- When the interiors of the geometries A and B are partially on top of each other and partially outside of each other, the geometries are *overlapping* with each other.
- The spatial predicate for *covers* is when the interior of geometry B is almost totally within A, but they share at least one common coordinate at the border.
- Similarly, if geometry A is almost totally contained by the geometry B (except at least one common coordinate at the border) the spatial predicate is called *covered by*. 
:::

## Topological spatial relations
:::{.callout-tip icon=false}
## Making spatial queries in Python

In Python, all the basic spatial predicates are available from `shapely` library, including:
 
 - `.intersects()`
 - `.within()`
 - `.contains()`
 - `.overlaps()`
 - `.touches()`
 - `.covers()`
 - `.covered_by()`
 - `.equals()`
 - `.disjoint()`
 - `.crosses()`
:::

## Topological spatial relations
:::{.callout-tip icon=false}
## Making spatial queries in Python

When you want to use Python to find out how two geometric objects are related to each other topologically, you start by creating the geometries using `shapely` library. In the following, we create a couple of `Point` objects and one `Polygon` object which we can use to test how they relate to each other: 

```{python}
#| echo: true
from shapely import Point, Polygon

# Create Point objects
point1 = Point(24.952242, 60.1696017)
point2 = Point(24.976567, 60.1612500)

# Create a Polygon
coordinates = [
    (24.950899, 60.169158),
    (24.953492, 60.169158),
    (24.953510, 60.170104),
    (24.950958, 60.169990),
]
polygon = Polygon(coordinates)
```
:::

## Topological spatial relations
:::{.callout-tip icon=false}
## Making spatial queries in Python
We can check the contents of the new variables by printing them to the screen, for example, in which case we would see

```{python}
#| echo: true
print(point1)
print(point2)
print(polygon)
```

If you want to test whether these `Point` geometries stored in `point1` and `point2` are within the `polygon`, you can call the `.within()` method as follows:

```{python}
#| echo: true
point1.within(polygon)
```

```{python}
#| echo: true
point2.within(polygon)
```
:::

## Topological spatial relations {.scrollable}
:::{.callout-tip icon=false}
## Making spatial queries in Python

One of the most common spatial queries is to see if a geometry intersects or touches another one. Again, there are binary operations in `shapely` for checking these spatial relationships:

- `.intersects()` - Two objects intersect if the boundary or interior of one object intersect in any way with the boundary or interior of the other object.
- `.touches()` - Two objects touch if the objects have at least one point in common and their interiors do not intersect with any part of the other object.
   
Let's try these by creating two `LineString` geometries and test whether they intersect and touch each other:

```{python}
#| echo: true
from shapely import LineString, MultiLineString

# Create two lines
line_a = LineString([(0, 0), (1, 1)])
line_b = LineString([(1, 1), (0, 2)])
```

```{python}
#| echo: true
line_a.intersects(line_b)
```

```{python}
#| echo: true
line_a.touches(line_b)
```

As we can see, it seems that our two `LineString` objects are both intersecting and touching each other. We can confirm this by plotting the features together as a `MultiLineString`:
<!-- #endregion -->

```{python}
#| echo: true
# Create a MultiLineString from line_a and line_b
multi_line = MultiLineString([line_a, line_b])
multi_line
```
:::

## Topological spatial relations {.scrollable}
:::{.callout-tip icon=false}
## Making spatial queries in Python

However, if the lines are fully overlapping with each other they don't touch due to the spatial relationship rule in the DE-9IM. We can confirm this by checking if `line_a` touches itself:

```{python}
#| echo: true
line_a.touches(line_a)
```

No it doesn't. However, `.intersects()` and `.equals()` should produce `True` for a case when we compare the `line_a` with itself:

```{python}
#| echo: true
print("Intersects?", line_a.intersects(line_a))
print("Equals?", line_a.equals(line_a))
```
:::

## Topological spatial relations
:::{.callout-tip icon=false}
## Exercise

Use python to prove that `line_a` and `line_b` are not identical.

<!--
```python editable=true slideshow={"slide_type": ""} tags=["remove_book_cell", "hide-cell"]
# Solution

print("Line a is equal to line b: ", line_a.equals(line_b))
```
-->
:::

## Topological spatial relations {.scrollable}
:::{.callout-tip icon=false}
## Making spatial queries in Python
Following the syntax from the previous examples, we can test all different spatial predicates and assess the spatial relationship between geometries. The following prints results for all predicates between the `point1` and the `polygon` which we created earlier: 

```{python}
#| echo: true
print("Intersects?", point1.intersects(polygon))
print("Within?", point1.within(polygon))
print("Contains?", point1.contains(polygon))
print("Overlaps?", point1.overlaps(polygon))
print("Touches?", point1.touches(polygon))
print("Covers?", point1.covers(polygon))
print("Covered by?", point1.covered_by(polygon))
print("Equals?", point1.equals(polygon))
print("Disjoint?", point1.disjoint(polygon))
print("Crosses?", point1.crosses(polygon))
```
:::

Looking at all the spatial predicates, we can see that the spatial relationship between our point and polygon object produces three `True` values: The point and polygon intersect with each other, the point is within the polygon, and the point is covered by the polygon. All the other tests correctly produce `False`, which matches with the logic of the `DE-9IM` standard. 
:::

:::{.callout-note}
## `within` vs `contains`

-  if you have many points and just one polygon and you try to find out which one of them is inside the polygon: You might need to check the separately for each point to see which one is `.within()` the polygon.
-  if you have many polygons and just one point and you want to find out which polygon contains the point: You might need to check separately for each polygon to see which one(s) `.contains()` the point.
:::

## Spatial relations
:::{.callout-tip icon=false}
## Spatial queries using geopandas

```{python}
#| echo: true
import geopandas as gpd

points = gpd.read_file("_data/Helsinki/addresses.shp")
districts = gpd.read_file("_data/Helsinki/Major_districts.gpkg")
```

```{python}
#| echo: true
print("Shape:", points.shape)
print(points.head())
```

```{python}
#| echo: true
print("Shape:", districts.shape)
print(districts.tail(5))
```

The data contains 34 address points and 23 district polygons.
:::

## Spatial relations {.scrollable}
:::{.callout-tip icon=false}
## Spatial queries using geopandas

For demonstration purposes, we are interested in finding all points that are within two areas in Helsinki region, namely `Itäinen` and `Eteläinen` (*'Eastern'* and *'Southern'* in English). Let's first select the districts using the `.loc` indexer and the listed criteria which we can use with the `.isin()` method to filter the data, as we learned already in Chapter 3:

```{python}
#| echo: true
selection = districts.loc[districts["Name"].isin(["Itäinen", "Eteläinen"])]
print(selection.head())
```

Let's now plot the layers on top of each other. The areas with red color represent the districts that we want to use for testing the spatial relationships against the point layer (shown with blue color):

```{python}
#| echo: true
base = districts.plot(facecolor="gray")
selection.plot(ax=base, facecolor="red")
points.plot(ax=base, color="blue", markersize=5)
```
:::

## Spatial relations {.scrollable}
:::{.callout-tip icon=false}
## Spatial queries using geopandas

As we can see from Figure 6.37, many points seem to be within the two selected districts. To find out which of of them are located within the Polygon, we need to conduct a Point in Polygon -query. We can do this by checking which Points in the `points` GeoDataFrame are *within* the selected polygons stored in the `selection` geodataframe. In the following, we will show how to take advantage of a method called `.sjoin()` for doing spatial queries between two GeoDataFrames. Normally, `.sjoin()` method is used for conducting a *{term}`spatial join`* between two spatial datasets, meaning that specific attribute information from a given GeoDataFrame is joined to the other one based on their topological relationship (see Chapter 6.7 for more details). However, spatial join can also be used as an efficient way to conduct spatial queries in `geopandas`. Consider the following example in which we use the `.sjoin()` method using `"within"` as the `predicate` parameter to select all points that are within the selected polygons: 
<!-- #endregion -->

```{python}
#| echo: true
selected_points = points.sjoin(selection.geometry.to_frame(), predicate="within")
```

```{python}
#| echo: true
ax = districts.plot(facecolor="gray")
ax = selection.plot(ax=ax, facecolor="red")
ax = selected_points.plot(ax=ax, color="gold", markersize=2)
```
:::

## Spatial relations {.scrollable}
:::{.callout-tip icon=false}
## Spatial queries using geopandas

As a result, we have now selected only the (golden) points that are inside the red polygons which is exactly what we wanted. Notice how we used the `selection.geometry.to_frame()` when calling the `.sjoin()` method. This is a special trick to avoid attaching any extra attributes from the `selection` geodataframe to our data, which is what `.sjoin()` method would normally do (and which it is actually designed for). As we are only interested in the geometries of the right-hand-side layer to do the selection, calling the `.geometry.to_frame()` will first select the geometry column from the `selection` layer and then converts it into a `GeoDataFrame` (which would otherwise be a GeoSeries). An alternative approach for doing the same thing is to use `selection[[selection.active_geometry_name]]`, which also returns a `GeoDataFrame` containing only a column with the geodataframe's active geometry.

In a similar manner, we can easily use the `.sjoin()` with other predicates to make selections based on how the geometries between two GeoDataFrames are related to each other. By default, the `.sjoin()` uses `"intersects"` as a spatial predicate, but it is easy to change this. For example, we can investigate which of the districts *contain* at least one point. In this case, we make a spatial join using the `disctricts` GeoDataFrame as a starting point, join the layer with the `points` and use the `"contains"` as a value to our `predicate` parameter:
<!-- #endregion -->

```{python}
#| echo: true
districts_with_points = districts.sjoin(
    points.geometry.to_frame(), predicate="contains"
)
```

```{python}
#| echo: true
ax = districts.plot(facecolor="gray")
ax = districts_with_points.plot(ax=ax, edgecolor="gray")
ax = points.plot(ax=ax, color="red", markersize=2)
```
:::

## Spatial relations {.scrollable}
:::{.callout-tip icon=false}
## Spatial queries using geopandas

As a result, we can now see that all the polygons marked with blue color were correctly selected as the ones which contain at least one point object. One important thing to remember whenever making spatial queries is that both layers need to share the same Coordinate Reference System for the selection to work properly. A typical reason for getting incorrect results when selecting data (likely an empty GeoDataFrame) is that one data layer is e.g. in WGS84 coordinate reference system whereas the other one is in some projected CRS, such as ETRS-LAEA. If this happens, you can easily fix the situation by defining and reprojecting both GeoDataFrames to same CRS using the `.to_crs()` method (see Chapter 6.4).  

Following the previous examples, you can easily test other topological relationships as well, by changing the value in `predicate` parameter. To find all possible spatial predicates for a given GeoDataFrame you can call:

```{python}
#| echo: true
districts.sindex.valid_query_predicates
```

As you can see, this list includes all typical spatial predicates which we covered earlier. But what is this `.sindex` that we use here? Let's investigate it a bit further: 

```{python}
#| echo: true
districts.sindex
```
:::
## Spatial relations {.scrollable}
:::{.callout-tip icon=false}
## Spatial queries using geopandas
As we can see, the `.sindex` is something called `SpatialIndex` object. This is something that `geopandas` prepares automatically for `GeoDataFrames` and as the name implies, it contains the *{term}`spatial index`* for our data. A spatial index is a special data structure that allows for efficient querying of spatial data. There are many different kind of spatial indices, but `geopandas` uses a spatial index called R-tree which is a hierarchical, tree-like structure that divides the space into nested, overlapping rectangles and indexes the bounding boxes of each geometry. The spatial index improves the performance of spatial queries, such as finding all objects that intersect with a given area. The `.sjoin()` method takes advantage of the spatial index and is therefore an extremely powerful and makes the queries faster (see Appendix 5 for further details). This comes very practical especially when working with large datasets and doing e.g. a point-in-polygon type of queries with millions of point observations. Hence, when selecting data based on topological relations, we recommend using `.sjoin()` instead of directly calling `.within()`, `.contains()` that come with the `shapely` geometries (as shown previously). 
<!-- #endregion -->

<!-- #region editable=true slideshow={"slide_type": ""} tags=["question"] -->
## Spatial relations
:::{.callout-tip icon=false}
## Exercise

How many addresses are located in each district? You can find out the answer by grouping the spatial join result based the district name (see Part I, chapter 3 for a reminder on how to group and aggregate data). 

<!--
```python editable=true slideshow={"slide_type": ""} tags=["remove_book_cell", "hide-cell"]
# Solution

# Check column names in the spatial join result
print(districts_with_points.columns.values)

# Group by district name
grouped = districts_with_points.groupby("Name")

# Count the number of rows (adress locations) in each district
grouped.index_right.count()
```
-->

<!-- #region editable=true slideshow={"slide_type": ""} -->


## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Description
Spatial join is yet another classic GIS task. Retrieving table attributes from one layer and transferring them into another layer based on their spatial relationship is something you most likely need to do on a regular basis when working with geographic data. In the previous section, you learned how to perform spatial queries, such as investigating if a Point is located within a Polygon. We can use this same logic to conduct a spatial join between two layers based on their spatial relationship and transfer the information stored in one layer into the other. We could, for example, join the attributes of a polygon layer into a point layer where each point would get the attributes of a polygon that `intersects` with the point. 

In Figure 6.41, we illustrate the logic of a spatial join by showing how it is possible to combine information between spatial data layers that are located in the same area (i.e. they overlap with each other at least partially). The target here is to combine attribute information of three layers: properties, land use and buildings. Each of these three layers has their own attribute information. Transfering the information between the layers is based on how the individual points in the Properties layer intersect with these layers as shown on the left, i.e. considering different land use areas (commercial, residential, industrial, natural), as well as the building footprints containing a variety of building-related attibute information. On the right, we show the table attributes for these three layers considering the features that intersect with the four Point observations. The table at the bottom shows how the results look after all the attribute data from these layers has been combined into a single table. 

It is good to remember that spatial join is always conducted between two layers at a time. Hence, in practice, if we want to make a spatial join between these three layers shown in Figure 6.41, we first need to conduct the spatial join between Properties and Land use, and then store this information into an intermediate result. After the first join, we need to make another spatial join between the intermediate result and the third layer (here, the Buildings dataset). After these two separate spatial joins, we have achieved the final result shown at the bottom, showing for each property (row) the corresponding attributes from the land use and building layers as separate columns. In a similar manner, you could also continue joining data (attributes) from other layers as long as you need.  

![_**Figure 6.41**. Spatial join allows you to combine attribute information from multiple layers based on spatial relationship._](img/spatial-join-basic-idea.png)
:::

## Spatial join {.scrollable}
:::{.callout-note icon=false}
## sjoin details
Now as we understand the basic idea behind the spatial join, let's continue to learn a bit more about the details of spatial join. Figure 6.42 illustrates how we can do a spatial join between Point and Polygon layers, and how changing specific parameters in the way the join is conducted influence the results. In spatial join, there are two set of options that you can control, which ultimately influence how the data is transferred between the layers. You can control: 

1) How the spatial relationship between geometries should be checked (i.e. spatial predicates), and
2) What type of table join you want to conduct (inner, left, or right outer join)

The spatial predicates control how the spatial relationship between the geometries in the two data layers is checked. Only those cases where the spatial predicate returns `True` will be kept in the result. Thus, changing this option (parameter) can have a big influence on your final results after the join. In Figure 6.41 this difference is illustrated at the bottom when you compare the result tables *i* and *ii*: In the first table (*i*) the spatial predicate is `within` that gives us 4 rows that is shown in the table. However, on the second result table (*ii*), the spatial predicate `intersects` gives us 5 rows. Why is there a difference? This is because the Point with id-number 6 happens to lie exactly at the border of the Polygon C. As you might remember from the  Chapter 6.6, there is a certain difference between these two spatial predicates: The `within` predicate expects that the Point should be inside the Polygon (`False` in our case), whereas `intersects` returns `True` if at least one point is common between the geometries (`True` in our case). In a similar manner, you could change the spatial predicate to `contains`, `touches`, `overlaps` etc. and the result would change accordingly. 

It is also important to ensure that the logic for investigating these spatial relationships makes sense when deciding which spatial predicate to use. For example, it would not make any sense to check whether Layer 1 (points) contain the Layer 2 (polygons) because Point objects do not have an interior or boundary, thus lacking the ability to contain any geometric object. Doing this kind of spatial join is possible, but the result from this type of spatial join would always return an empty `GeoDataFrame`.  However, if we change the spatial join criteria and join the data between layers if the Layer 2 (polygons) contain the Layer 1 (points), this would make a perfect sense, and the query would return rows that match with this criteria.   

![_**Figure 6.42**. Different approaches to join two data layers with each other based on spatial relationships._](img/spatial-join-alternatives.png)

:::
## Spatial join {.scrollable}
:::{.callout-note icon=false}
## sjoin type
The other parameter that you can use to control how the spatial join is conducted is the spatial join type. There are three different join types that influence the outcome of the spatial join:

1. `inner join`
2. `left outer join`
3. `right outer join`
:::

## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Spatial join with Python

<!-- #region editable=true slideshow={"slide_type": ""} -->
Now as we have learned the basic logic of spatial join, let's see how we can do it in Python. Spatial join can be done easily with `geopandas` using the `.sjoin()` method. Next, we will learn how to use this method to perform a spatial join between two layers:

1) `addresses` which are the locations that we geocoded previously;
2) `population grid` which is a 250m x 250m grid polygon layer that contains population information from the Helsinki Region (source: Helsinki Region Environmental Services Authority). Let's start by reading the data:

```{python}
#| echo: true
import geopandas as gpd

addr_fp = "_data/Helsinki/addresses.shp"
addresses = gpd.read_file(addr_fp)
addresses.head(2)
```

As we can see, the `addresses` variable contains address Points which represent a selection of public transport stations in the Helsinki Region.
:::
## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Spatial join with Python
```{python}
#| echo: true
pop_grid_fp = "data/Helsinki/Population_grid_2021_HSY.gpkg"
pop_grid = gpd.read_file(pop_grid_fp)
pop_grid.head(2)
```

The `pop_grid` dataset contains few columns, namely a unique `id`, the number of `inhabitants` per grid cell, and the `occupancy_rate` as percentage. 
:::

## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Preparations for spatial join

Check CRS:

```{python}
#| echo: true
print("Address points CRS:", addresses.crs.name)
print("Population grid CRS:", pop_grid.crs.name)
```

We can further verify that the crs are indeed not the same. 

```{python}
#| echo: true
addresses.crs == pop_grid.crs
```
:::

## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Preparations for spatial join
To fix this issue, let's reproject the geometries in the `addresses` `GeoDataFrame` to the same CRS as `pop_grid` using the `.to_crs()` method.

```{python}
#| echo: true
# Reproject
addresses = addresses.to_crs(crs=pop_grid.crs)

# Validate match
addresses.crs == pop_grid.crs
```
:::

## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Preparations for spatial join
Let's visualize both datasets on top of each other to see how the inhabitants are distributed over the region, and how the address points are located in relation to the grid:

```{python}
#| echo: true
# Plot the population data classified into 5 classes
ax = pop_grid.plot(
    column="inhabitants",
    cmap="Greens",
    scheme="naturalbreaks",
    k=5,
    legend=True,
    legend_kwds={"loc": "lower right"},
    figsize=(10, 8),
)

# Add address points on top using blue "Diamond" markers
ax = addresses.plot(ax=ax, color="blue", markersize=7, marker="D")
```
:::

## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Join the layers based on spatial relationship

The aim here is to get information about *How many people live in a given polygon that contains an individual address-point*?

Thus, we want to join the attribute information from the `pop_grid` layer into the `addresses` Point layer using the `.sjoin()` method.

Controlling the spatial predicate in the `.sjoin()` can be done using the `predicate` parameter. The most commonly used options for the `predicate` parameter are:

- "intersects" (the default option)
- "contains"
- "covered_by"
- "covers"
- "crosses"
- "overlaps"
- "touches"
- "within'

The join type, as we learned earlier, is the second option to control how the data will be merged. In `.sjoin()` method, this can be adjusted with the `how` parameter. The possible values for the `how` parameter are:

- `"inner"` (the default option)
- `"left"`
- `"right"`
:::

## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Join the layers based on spatial relationship

- we specify `predicate="within"` for the spatial predicate as we are interested to know *within* which polygon a given point is located;
- we specify the join type with `how="inner"` which means that only such rows are kept from both layers where the spatial predicate returns `True`.

<!-- This means that if there are points that are not inside of any of the Polygons, they will be dropped from the result. Thus, we formulate the command in the following form and store the result in the variable `join`: -->

```{python}
#| echo: true
join = addresses.sjoin(pop_grid, predicate="within", how="inner")
join
```
:::


## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Join the layers based on spatial relationship
Let's also visualize the joined output. In the following, we plot the points using the `inhabitants` column to indicate the color:

```{python}
#| echo: true
ax = join.plot(
    column="inhabitants",
    cmap="Reds",
    markersize=15,
    scheme="quantiles",
    legend=True,
    figsize=(10, 6),
)
ax.set_title("Amount of inhabitants living close to the point");
```

:::

## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Join the layers based on spatial relationship
As we see from the map, the number of population living close to the stations vary quite significantly ranging from 43 up to 1409 inhabitants. As a last thing after the spatial join, it is useful to investigate if we lost any data while doing the spatial join. Let's check this by comparing the number of rows in our result to how many addresses we had originally:

```{python}
#| echo: true
len(addresses) - len(join)
```

As we can see, there seems to be three Points that were located outside of the populated grid cells. If we plot the layers on top of each other as an interactive map, we can investigate where the points outside of polygons are located:

```{python}
#| echo: true
m = pop_grid.explore(color="blue", style_kwds=dict(color="blue", stroke=False))
addresses.explore(m=m, color="red")
```
:::

## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Join the layers based on spatial relationship

We can see that some points are located outside of polygons in the areas close to the railway lines and the motorway. Is this a problem? It depends, but in certain cases, you might want to keep the information for the points that did not get a match based on the spatial relationship. We can achieve this by changing the `how` parameter into `left`, which keeps every row from the left member of the spatial join even when no match is found from the other layer:

```{python}
#| echo: true
# This cell sets the number of lines of pandas output to a maximum of 7
# The cell is removed when building the website/book PDF
pd.set_option("display.max_rows", 7)
```

```{python}
#| echo: true
left_join = addresses.sjoin(pop_grid, predicate="within", how="left")
left_join
```

Now the result in the `left_join` contains all the original 34 addresses. Let's investigate a bit more to see which rows did not have a matching polygon in the population grid. After a left-join, those rows that do not have a matching geometry in the right-side member of the join are filled with NaN values. Thus, we should be able to locate them easily by searching for rows that do not have any values e.g. in the `inhabitants` column that was part of the `pop_grid` `GeoDataFrame`. We can do this by doing a selection using the `.isnull()` method:

```{python}
#| echo: true
left_join.loc[left_join["inhabitants"].isnull()]
```

The result from this query reveals the exact locations of the points that miss information in the last four columns of the `GeoDataFrame`. Okay, but is this all we can do? In some cases, it can be crucial that all features in the target layer would get information from the other dataset even if the spatial predicate between the geometries would not match perfectly. Sometimes fetching information from another layer based on the closest geometry up to a certain distance threshold can be considered sufficient for making a spatial join. Luckily, we can achieve this with relative ease using `geopandas` which we will learn next.

## Spatial join {.scrollable}
:::{.callout-note icon=false}
## Exercise

Do the spatial join another way around, i.e. make a spatial join where you join information from the address points into the population grid. How does the result differ from the version where we joined information from the grids to the points? What would be the benefit of doing the join this way around?
<!--

```python editable=true slideshow={"slide_type": ""} tags=["remove_book_cell", "hide-cell"]
# Solution

# Join information from address points to the grid
result = pop_grid.sjoin(addresses)

# Check the structure
print(result.head(2))

# Visualize the result
result.explore()

# see reflection about this solution in the back matter
```
-->

# Nearest neighbour analysis

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Neighbourhood
The idea of neighbourhood is one of the fundamental concepts in geographic data analysis and modelling. Being able to understand how close geographic objects are to each other, or which features are neighboring a specific location is fundamental to various spatial analysis techniques, such as spatial interpolation (which we cover in Chapter 10) or understanding whether there is spatial autocorrelation (i.e. clustering) in the data (see Chapters [6](https://geographicdata.science/book/notebooks/06_spatial_autocorrelation.html) and [7](https://geographicdata.science/book/notebooks/07_local_autocorrelation.html) in {cite}`Rey_et_al_2023`). Many of these techniques rely on the idea that proximity in geographic space typically indicates also similarity in attribute space. For example, it is quite typical that a neighborhood with high population density is next to another neighborhood that also has high concentration of residents (i.e. population density tends to cluster). One of the most famous notions related to this is the *First law of geography* which states that "everything is related to everything, but near things are more related than distant things" ({cite}`Tobler1970`). Thus, being able to understand how close neighboring geographic features are, or which objects are the closest ones to specific location is an important task in GIS. 

Figure 6.45 illustrates two common ways to find nearest neighbors to specific locations. In these examples, we have two Point datasets visualized with blue circles and red rectangles that are used for doing the nearest neighbor analysis. In the first example (top row), the idea is to find the closest geometry (rectangles) for all the points in the area. Here, the nearest neighbor is determined based on distance between the points and rectangles, and the nearest neighbors are visualized with a line from every point to the closest rectangle (on the right). The bottom row shows an example in which we aim to find the closest point for each rectangle, but in this case we also apply a maximum search distance that limits the search area. Only those points that are within the search area are considered when finding the nearest neighbor, while the points outside of this area are simply ignored. As a result, the point closest to a given rectangle is visualized with a connected line (on the right). In these examples, the geographic objects are simple point like features, but similar approach can be used with any geographic features, for example by finding closest LineString or Polygon geometry to a given Point, or by finding the closest Polygon to another Polygon. In these cases, the calculations are a bit more complicated, but the basic idea is the same. 

![_**Figure 6.46**. The basic idea of finding a nearest neighbour based on geographic distance._](img/nearest-neighbour.png)
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
Quite often with very large datasets, we might want to limit the search area up to a specific maximum distance. This can be due to practical reasons as it can significantly speed up the computation time, or because we have specific reasoning that makes it sensible to limit the search area. For example, if we would aim to understand how easily accessible public transportation is to citizens living in a city, it would make sense to limit the search area e.g. up to 2 km from the homes of people, because people are not willing to walk for very long distances to reach a bus stop. It's important to notice that the distances in the calculations are commonly based on the Euclidean distance, i.e. we calculate the distances based on coordinates on a Cartesian plain, meaning that the distances do not consider changes in height (i.e. third dimension is omitted). It is of course possible also to consider 3D distances, but the most typical Python tools ignore the height information. 

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbour analysis in Python

In Python, there are various libraries that can be used to find nearest neighbors for given set of geometries, including `geopandas`, `shapely`, `scipy`, `scikit-learn`, and `pysal` among others. Here, we first introduce how `geopandas` can be used to find the nearest neighbors for all Point geometries in a given `GeoDataFrame` based on `Point`objects from another `GeoDataFrame`. Then we show how to find nearest neighbor between two Polygon datasets, and finally we show how to use `scipy` library to find K-Nearest Neighbors (KNN) with Point data.


In the following, we go through a very practical example that relates to our daily commute: Where is the closest public transport stop from my place of residence? Hence, our aim is to search for each building point in the Helsinki Region the closest public transport stop. In `geopandas`, we can find nearest neighbors for all geometries in a given `GeoDataFrame` using the `.sjoin_nearest()` method. To test it out, let's start by reading two datasets representing buildings and stops and visualize them to understand a bit better what we have:

```{python}
#| echo: true
import geopandas as gpd
import matplotlib.pyplot as plt

stops = gpd.read_file("data/Helsinki/pt_stops_helsinki.gpkg")
building_points = gpd.read_file("data/Helsinki/building_points_helsinki.zip")

print("Number of stops:", len(stops))
stops.head(2)
```

```{python}
#| echo: true
print("Number of buildings:", len(building_points))
building_points.head(2)
```

As we can see, both `GeoDataFrames` contain `Point` geometries. There seems to be approximately 8400 stops and almost 159 thousand buildings. Hence, we have already a fair amount of data and calculations to do, to find the nearest neighbor for each building. Let's still visualize these data side-by-side:

```{python}
#| echo: true
fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(15, 10))

# Plot buildings
building_points.plot(ax=ax1, markersize=0.2, alpha=0.5)
ax1.set_title("Buildings")

# Plot stops
stops.plot(ax=ax2, markersize=0.2, alpha=0.5, color="red")
ax2.set_title("Stops");
```
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbour analysis in Python
As mentioned earlier, finding the nearest geometries between two `GeoDataFrames` (here building and stop points) can be done easily using the `.sjoin_nearest()` method in `geopandas`. As the name implies, this method is actually designed to merge data between `GeoDataFrames` in a similar manner as with regular `.sjoin()` method. However, in this case the method is actually searching for the closest geometries instead of relying on spatial predicates, such as *within*. The `sjoin_nearest()` can be used for different geometry types, so the input geometries do not necessarily need to be Point objects as in our example. Under the hood, the method uses a *{term}`spatial index`* called `STRTree` ({cite}`leutenegger_1997`) which is an efficient implementation of the *{term}`R-tree`* dynamic index structure for spatial searching ({cite}`guttman_1984`). The STRTree is implemented in the `shapely` library (used by `geopandas`) and the technique makes the nearest neighbor queries very efficient. You can read more about spatial indices in Appendices section of the book. For the method to work properly, it is recommended to ensure that the both `GeoDataFrames` are having the same coordinate reference system (CRS), and preferably having a projected (metric) CRS because that ensures that the reported distances are meaningful (in meters) and correct. Hence, let's start by reprojecting our latitude and longitude values into a metric system using the national EUREF-FIN coordinate reference system (EPSG code 3067) for Finland:
<!-- #endregion -->

```{python}
#| echo: true
stops = stops.to_crs(epsg=3067)
building_points = building_points.to_crs(epsg=3067)

stops.head(2)
```
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbour analysis in Python
Now the `GeoDataFrames` are surely in the same coordinate system and we can see that the coordinates in the `geometry` column have changed representing meters. Next, we will use the `buildings.sjoin_nearest()` to find the closest stop for each building. Because we are interested to find the closest stop geometry for each building, the `buildings` `GeoDataFrame` is on the left hand side of the command. As inputs, we pass the `stops` `GeoDataFrame` as well as give a name for a column which is used to store information about the distance between a given building and the closest stop (this is optional):
<!-- #endregion -->

```{python}
#| echo: true
%time
closest = building_points.sjoin_nearest(stops, distance_col="distance")
closest
```
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbour analysis in Python

As a result, we now have found the closest stop for each building including the attributes of the closest stops that were merged into the results. The last column in the table shows the distance in meters between a given building and the closest stop. The distance is only returned upon request as we did by specifying `distance_col="distance"`. The column `index_right` provides information about the index number of the closest stop in the `stops` `GeoDataFrame`. If you look carefully, you can see that the number of rows in our result has actually increased slightly from the original (158731 vs 159818). This happens because for some geometries in the `buildings` `GeoDataFrame`, the distance between the building and two (or more) stops have been exactly the same (i.e. they are equidistant). In such cases, the `sjoin_nearest()` will store both records into the results by duplicating the building information and attaching information from the stops into separate rows accordingly. In some cases, this can cause trouble for further analysis, so it is good to be careful and investigate whether any duplicate buildings have appeared into the results. If this is the case, and if the duplicates cause issues in your analysis, you might need to pick one of them for further analysis based on some criteria. A simple way is to pick the first (or last) duplicate if you do not have any specific justification for making the selection.

The `%time` command at the beginning of the cell provides us some details about the time it took to find the nearest neighbors and merge the data between the two data sets. As we can see, the computations are very efficient taking only a matter of some microseconds for almost 159 thousand observations. We can make this even faster by specifying a `max_distance` parameter that specifies the maximum search distance. Here, we specify the maximum distance as 100 meters from each building:
<!-- #endregion -->

```{python}
#| echo: true
%time
closest_limited = building_points.sjoin_nearest(
    stops, max_distance=100, distance_col="distance"
)
closest_limited
```
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbour analysis in Python

As we can see, there was a slight improvement in the execution time compared to the previous call without specifying the `max_distance` parameter. The difference can be more significant if you have larger datasets or more complicated geometries (e.g. Polygons). One important aspect to notice from these results is that the number of rows has decreased significantly: from 160 to 40 thousand buildings. This happens because our search distance was very low (100 meters), and as a consequence, there were many buildings that did not have any stops within 100 meter radius from them. Because the default join type in `sjoin_nearest` is `inner` join, all the records that did not have a stop within 100 meters were dropped. If you would like to keep all the records in the results, to e.g. investigate which buildings do not have any stops within the search radius, you can add parameter `how="left"`, which will retain all buildings from the original `GeoDataFrame`.

In some cases, you might actually want to connect the nearest neighbors to each other with a straight line. For doing this, we need to merge also the Point geometries from the other layer into our results, which can then be used to create a LineString connecting the points to each other. This can be useful for many purposes, but in our case, we want to do this to be able to validate whether our results are correct. For merging the closest stop geometries into our results, we can take advantage of the `index_right` column in our table and conduct a normal table join using the `.merge()` method. Below, we create a table join between the tables using the `.merge()` and use the `"index_right"` column in the `closest` `GeoDataFrame` as a key on the left table while the index of the `stops` is used as the key on the right table. Notice that we only keep the `geometry` columns from the `stops` `GeoDataFrame` because all the other attributes already exist in our results: 

```{python}
#| echo: true
closest = closest.merge(
    stops[[stops.active_geometry_name]], left_on="index_right", right_index=True
)
closest.head()
```
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbour analysis in Python
As a result, we now brought a new column into our results, namely the `geometry_y`. Because there was a column called `geometry` in both `GeoDataFrames`, `geopandas` automatically renamed the columns into `geometry_x` and `geometry_y` respectively. 

Now we have all the data that we need to create a connecting `LineString` between the buildings and the closest stops. We can do this by using the `linestrings()` function of the `shapely` library which is a fast (vectorized) way to create a number of `LineString` objects based on point coordinates (the function only accepts numbers as input, i.e. not `Point` objects). To extract the point coordinates from the `Point` objects stored in the `geometry_x` and `geometry_y` columns, we use the `.get_coordinates()` method of `geopandas` that returns the `x` and `y` coordinates as `Series` objects/columns. Then we convert these into `numpy` arrays using the `to_numpy()` method which we pass to the `linestrings()` function. Finally, we store the resulting `LineStrings` into a column `geometry` which we set as the active geometry of the `GeoDataFrame`:    

```{python}
#| echo: true
from shapely import linestrings

closest["geometry"] = linestrings(
    closest.geometry_x.get_coordinates().to_numpy(),
    closest.geometry_y.get_coordinates().to_numpy(),
)

closest = closest.set_geometry("geometry")
closest.head()
```
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbour analysis in Python
Great! Now we have created a new geometry column that contains the lines between buildings and the closest stops. To better understand the results, let's create a nice map that visualizes the buildings, stops and the connecting lines between the buildings and the closest stops in a single figure: 

```{python}
#| echo: true
ax = closest.plot(lw=0.5, figsize=(10, 10))
ax = building_points.plot(ax=ax, color="red", markersize=2)
ax = stops.plot(ax=ax, color="black", markersize=8.5, marker="s")
# Zoom to specific area
ax.set_xlim(382000, 384100)
ax.set_ylim(6676000, 6678000);
```
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbour analysis in Python
We can also do some descriptive analysis:
```{python}
#| echo: true
closest["distance"].describe()
```

As we can see, the average distance to public transport in the region is around 230 meters. More than 75 % of the buildings seem to be within within 3.5 minute walking time (~260 meters with walking speed of 4.5 kmph) which indicates very good situation in terms of accessibility levels in the region overall. There seem to be some really remote buildings in the data as well, as the longest distance to closest public transport stop is more than 7 kilometers.
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbors with Polygon and LineString data

In some cases, you might need to find the closest neighbors for a given set of Polygons or LineStrings. Luckily, the `sjoin_nearest()` method works in a similar manner with all geometry types, i.e. you can find the nearest neighbors using Point, LineString, Polygon, MultiPoint, MultiLineString and MultiPoint geometries as input. Also finding nearest neighbors between different geometry types is supported, meaning that you can for example search nearest LineStrings to Polygons, and so on. When using more complex geometries as input (e.g. LineStrings or Polygons), the nearest neighbor search uses spatial index, i.e. it creates bounding boxes around the input geometries and inserts them into an R-Tree which is used to make the search queries more efficient. However, the distance between the nearest neighbours is measured based on the true shapes of the geometric features. In the following, we demonstrate how to conduct nearest neighbor analysis with more complex geometries, such as Polygons and LineStrings.

As a real-life case, we first aim to find the closest urban park to building polygons in a neighborhood called Kamppi, which is located in Helsinki, Finland. Then, we aim to find the closest drivable road (LineString) to each building. Let's start by reading the data and visualize it on a map:

```{python}
#| echo: true
import geopandas as gpd

buildings = gpd.read_file("data/Helsinki/Kamppi_buildings.gpkg")
parks = gpd.read_file("data/Helsinki/Kamppi_parks.gpkg")
roads = gpd.read_file("data/Helsinki/Kamppi_roads.gpkg")
buildings
```

```{python}
#| echo: true
# Plot buildings, parks and roads
ax = buildings.plot(color="gray", figsize=(10, 10))
ax = parks.plot(ax=ax, color="green")
ax = roads.plot(ax=ax, color="red")
```
:::
_**Figure 6.49**. A map showing the buildings with gray color and the parks (green) in the neighborhood of Kamppi, Helsinki._

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbors with Polygon and LineString data
Similarly as finding the nearest neighbor using Points as input data, we can use the `.sjoin_nearest()` to find nearest neighbor between two Polygon datasets. Here, we find the nearest park for each building Polygon and store the distance into the column `distance`:

```{python}
#| echo: true
nearest_parks = buildings.sjoin_nearest(parks, distance_col="distance")
nearest_parks
```

```{python}
#| echo: true
print("Maximum distance:", nearest_parks["distance"].max().round(0))
print("Average distance:", nearest_parks["distance"].mean().round(0))
```
:::

Now we have found the nearest park for each building, and as we can see on average the closest park seem to be 61 meters away from the buildings while the longest distance from one of the buildings to the closest park seems to be 229 meters. 
<!-- #endregion -->

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbors with Polygon and LineString data
In a similar manner, we can also find the nearest road from each building as follows:
```{python}
#| echo: true
nearest_roads = buildings.sjoin_nearest(roads, distance_col="distance")
nearest_roads
```
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbors with Polygon and LineString data
As a result, we now have found the nearest road for each building. We have now 703 rows of data which means that for some buildings there have been more than one road that are exactly the same distance apart. To better understand how the spatial join between the buildings and roads have been conducted, we can again visualize the nearest neighbors with a straight line. To do this, we first bring the geometries from the `roads` `GeoDataFrame` into the same table with the buildings: 

```{python}
#| echo: true
nearest_roads = nearest_roads.merge(
    roads[["geometry"]], left_on="index_right", right_index=True
)
nearest_roads.head(3)
```
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbors with Polygon and LineString data
Now we have the `geometry_x` column representing the building geometries and the `geometry_y` column representing the road geometries (LineStrings). To visualize the connecting lines between buildings and roads, we first need to create geometries that connect the building and closest road geometry from the locations where the distance is shortest. To do this, we can take advantage of a handy function called `shortest_line()` from the `shapely` library that returns a LineString object between the input geometries showing the shortest distance between them. Based on these, we can create a connecting line between a given building and the closest road. Finally, we create a new `GeoDataFrame` called `connectors` out of these lines and also store the length of the `LineString`s as a separate column:

```{python}
#| echo: true
from shapely import shortest_line


# Generate LineString between nearest points of two geometries
connectors = nearest_roads.apply(
    lambda row: shortest_line(row["geometry_x"], row["geometry_y"]), axis=1
)

# Create a new GeoDataFrame out of these geometries
connectors = gpd.GeoDataFrame({"geometry": connectors}, crs=roads.crs)
connectors["distance"] = connectors.length
connectors.head()
```
:::


## Nearest neighbour analysis
:::{.callout-important icon=false}
## Nearest neighbors with Polygon and LineString data
Great, now we have a new `GeoDataFrame` that represents the connectors between the buildings and the drivable roads. Finally, we can visualize the buildings, roads and these connectors to better understand the exact points where the distance between a given building and the closest road is shortest:

```{python}
#| echo: true
m = buildings.explore(color="gray", tiles="CartoDB Positron")
m = roads.explore(m=m, color="red")
m = connectors.explore(m=m, color="green")
m
```
:::

## Nearest neighbour analysis
:::{.callout-important icon=false}
## Exercise

What is the closest road to each park? Use the `parks` and `roads` `GeoDataFrames` and follow the approaches presented above to find the closest road to each park. What is the highest (maximum) distance between parks and roads present in our datasets?

<!--
```python editable=true slideshow={"slide_type": ""} tags=["remove_book_cell", "hide-cell"]
# Solution

# Find the nearest road
nearest_park_roads = parks.sjoin_nearest(roads, distance_col="distance")

# What is the maximum distance?
max_dist = nearest_park_roads["distance"].max()
print(f"Maximum distance is {max_dist:.2f} meters.")
```
-->

# K-Nearest Neighbor search

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## Overview

Thus far, we have only focused on finding the nearest neighbor to a given geometry. However, quite commonly you might want to find not only the closest geometry, but a specific number of closest geometries to a given location (1st closest, 2nd closest, and so on). For example, you might be interested to find 3-5 closest public transport stops from your home, because these stops might provide alternative connections to different parts of the city. Doing these kind of queries is a common procedure and a prerequisite for many data analysis techniques, and the technique is commonly called as *{term}`K-Nearest Neighbors search`* (or KNN search). Next, we will learn how to find *k* number of closest neighbors based on two `GeoDataFrames`. We will first aim to find the three nearest public transport stops for each building in the Helsinki Region, and then we will see how to make a *{term}`radius query`* to find all neighbors within specific distance apart from a given location. K-Nearest Neighbor search techniques are also typically built on top of *{term}`spatial indices <spatial index>`* to make the queries more efficient. Previously, with `sjoin_nearest()`, we used an `R-tree` index structure to efficiently find the nearest neighbor for any kind of geometry. However, because the R-tree implementation in Python only supports finding the closest neighbor (a limitation in the underlying GEOS software), we need to use another tree structure called *{term}`KD-Tree`* (K-dimensional tree) that can provide us information about K-nearest neighbors (i.e. not only the closest). KD-tree is similar to R-tree, but the data is ordered and sorted in a bit different manner (see Appendices for further details). 
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## kNN in Python
In Python, we can conduct KNN search between Point datasets using the `scipy` library. Before we can do the actual query, we need to build the `KD-Tree` spatial index. In scipy, we can use the `KDTree` to build the spatial index which is available from the `scipy.spatial` submodule. The `KDTree` has been implemented in C-language which makes it very fast. In the following, we use the `building_points` and `stops` `GeoDataFrames` that we already used earlier to find three closest public transport stops for each building. Let's start by reading the data and reproject the data into a metric coordinate reference system (EPSG:3067) so that the distances will be presented as meters:
<!-- #endregion -->

```{python}
#| echo: true
import geopandas as gpd

# Read the files and reproject to EPSG:3067
stops = gpd.read_file("_data/Helsinki/pt_stops_helsinki.gpkg").to_crs(epsg=3067)
building_points = gpd.read_file("_data/Helsinki/building_points_helsinki.zip").to_crs(
    epsg=3067
)

building_points.head(2)
```

```{python}
#| echo: true
stops.head(2)
```

```{python}
#| echo: true
stops.shape
```

As we see, both datasets include Point geometries representing specific buildings and public transport stops (n=8377). 
:::


## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree
As a first step, we need to build a `KDTree` index structure based on the Point coordinates. The `KDTree` class expects the Point coordinates to be in `array` format, i.e. not as shapely `Point` objects which we have stored in the `geometry` column. Luckily, it is very easy to convert the shapely geometries into `numpy.array` format by chaining a method `.get_coordinates()` with the `.to_numpy()` method as follows: 

```{python}
building_coords = building_points.get_coordinates().to_numpy()
stop_coords = stops.geometry.get_coordinates().to_numpy()

stop_coords
```
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree

By running these commands, the `.get_coordinates()` method first returns a DataFrame with `x` and `y` coordinates as columns, and the `.to_numpy()` method then converts this data into a numpy `array` as we see above. The `stop_coords` variable now contains an array of coordinate tuples (x and y coordinates) which we can pass to the `KDTree` class and create a KD-Tree index structure as follows: 

```{python}
#| echo: true
from scipy.spatial import KDTree

stop_kdt = KDTree(stop_coords)
stop_kdt
```
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree
Now we have initialized a `KDTree` index structure by populating it with stop coordinates. By doing this, we can make very efficient queries to find out which of the ~8000 stops is closest to specific buildings. To do this, we can use the `.query()` method which goes through all the input coordinates (i.e. buildings) and very quickly calculates which of them is the closest, 2nd closest etc. The method returns the distances to the K-number of nearest neighbors as well as the index of the closest `stop` to the given building. By passing an argument `k=3`, we can specify that we want to find three closest neighbors for each building: 

```{python}
# Find the three nearest neighbors from stop KD-Tree for each building
k_nearest_dist, k_nearest_ix = stop_kdt.query(building_coords, k=3)

len(k_nearest_dist)
```
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree

The `stop_kdt.query()` call returns us two objects. The first one which we store to variable `k_nearest_dist` represents an array/list of distances from each building (n=158 731) to the three of the closest public transport stops in the data. The second variable `k_nearest_ix` represents the index values of the three nearest stops for each building: 

```{python}
#| echo: true
# Distances to 3 nearest stops
k_nearest_dist
```

```{python}
#| echo: true
# Index values of the 3 nearest stops
k_nearest_ix
```
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree
Based on these arrays, we can see that the closest stop to the first building in our data is 92.7 meters away from the building, while the second and third closest stops are approximately 460 meters away from the given building. By looking at the index values in the `k_nearest_ix` variable, we can see that the stops with indices 1131, 1135 and 1125 seem to be the three closest public transport stops to the first building in our data. 

Now we have successfully computed the K-nearest neighbors between the buildings and the stops. Next, we will attach this information back to our `GeoDataFrame` so that it is easier to do further analyses with the data and create some nice maps out of the data. The data which is returned by the `stop_kdt.query()` command comes out as an array of lists, where each item (list) contains three values that show the distances between three nearest stops and the given building. To be able to easily merge this data with the original `GeoDataFrame` containing the building data, we need to transpose our arrays. After the transpose, the data will be restructured in a way that there will be three arrays and each of these arrays contains the distances/stop-ids for all the buildings in a single list. To transpose a numpy array, we can use the method `.T` which does the trick:

```{python}
#| echo: true
k_nearest_ix.T
```
:::
## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree
By following this approach, we can store the index and distance information as columns into our `GeoDataFrame` containing values for the 1-3 nearest stops. In the following, we first create a clean copy of the `building_points` `GeoDataFrame` into variable `k_nearest`, which we will then populate with three new columns for the stop indices, and three columns for the distances to the 1-3 closest stops. To access the information for the closest stop, we can call `.T[0]`, while the `.T[1]` and `.T[2]` returns the information for the second and third closest stops accordingly:

```{python}
#| echo: true
# Make a copy
k_nearest = building_points.copy()

# Add indices of nearest stops
k_nearest["1st_nearest_idx"] = k_nearest_ix.T[0]
k_nearest["2nd_nearest_idx"] = k_nearest_ix.T[1]
k_nearest["3rd_nearest_idx"] = k_nearest_ix.T[2]

# Add distances
k_nearest["1st_nearest_dist"] = k_nearest_dist.T[0]
k_nearest["2nd_nearest_dist"] = k_nearest_dist.T[1]
k_nearest["3rd_nearest_dist"] = k_nearest_dist.T[2]
```

```{python}
#| echo: true
k_nearest.head()
```
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree
Perfect! Now we have stored the information for each building about the indices and distances to the three of the closest stops around given buildings. To make this information easier to understand, we can make a nice map that shows the closest three stops for each building. To do this, we can follow a similar approach as we used earlier when visualizing the results from the `sjoin_nearest()` function. Namely, we bring the geometry from the k-nearest stops and connect the building Points with the given stop Points with a LineString. Then it is easy to visualize the closest stops for each building. In the following, we create three separate `GeoDataFrames` that correspond to the nearest, second nearest and third nearest stops from the buildings. We start by storing the `stop_index` as a column which allows us to easily merge the data between `stops` and `k_nearest` (buildings) GeoDataFrames. For making the table join, we can use the pandas `.merge()` function in which we use the `1st_nearest_idx`,  `2nd_nearest_idx` and `3rd_nearest_idx` as the key on the left `GeoDataFrame`, while the `stop_index` is the key on the right `GeoDataFrame`. We also pass the `suffixes=('', '_knearest)` argument to the `.merge()` method to specify that the column names on the left-side `GeoDataFrame` should stay as they are, while the column names on the right-side will get a suffix `_knearest` in case there are identical column names present in both `GeoDataFrames` (which we have as both frames contain the `geometry` column. Let's see how we can create these three `GeoDataFrames` and store them into `k_nearest_1`, `k_nearest_2` and `k_nearest_3` variables:

```{python}
#| echo: true
# Store the stop index for making the table join
stops["stop_index"] = stops.index
```

```{python}
#| echo: true
# Merge the geometries of the nearest stops to the GeoDataFrame
k_nearest_1 = k_nearest.merge(
    stops[["stop_index", "geometry"]],
    left_on="1st_nearest_idx",
    right_on="stop_index",
    suffixes=("", "_knearest"),
)
k_nearest_1.head(2)
```
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree
```{python}
#| echo: true
# Merge the geometries of the 2nd nearest stops to the GeoDataFrame
k_nearest_2 = k_nearest.merge(
    stops[["stop_index", "geometry"]],
    left_on="2nd_nearest_idx",
    right_on="stop_index",
    suffixes=("", "_knearest"),
)
k_nearest_2.head(2)
```

```{python}
#| echo: true
# Merge the geometries of the 3rd nearest stops to the GeoDataFrame
k_nearest_3 = k_nearest.merge(
    stops[["stop_index", "geometry"]],
    left_on="3rd_nearest_idx",
    right_on="stop_index",
    suffixes=("", "_knearest"),
)
k_nearest_3.head(2)
```
:::


## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree
Excellent, now we have merged the stop geometries into the `geometry_knearest` columns. By comparing the values in the `stop_index` column of the `GeoDataFrames` `k_nearest_1`, `k_nearethe st_2` and `k_nearest_3`, we can see that the values change correctly following the values in `1st_`, `2nd_` and `3rd_nearest_index` column accordingly. The geometries stored in the `geometry_knearest` also have different values in all of the `GeoDataFrames` which is as expected. Now we can create `LineString` geometries connecting these `Point` objects to each other which allows us to create a nice map out of our nearest neighbors and thus better understand the data:

```{python}
#| echo: true
from shapely import LineString

# Generate LineStrings connecting the building point and K-nearest neighbor
k_nearest_1["geometry"] = k_nearest_1.apply(
    lambda row: LineString([row["geometry"], row["geometry_knearest"]]), axis=1
)
k_nearest_2["geometry"] = k_nearest_2.apply(
    lambda row: LineString([row["geometry"], row["geometry_knearest"]]), axis=1
)
k_nearest_3["geometry"] = k_nearest_3.apply(
    lambda row: LineString([row["geometry"], row["geometry_knearest"]]), axis=1
)

k_nearest_1.head(2)
```
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree
Now we have updated the `geometry` column of our datasets with `LineString` geometries connecting the building Point with the nearest stop geometries. Next, it is easy to visualize the closest three stops for each building. Because there are thousands of connections in our data, in the following, we select a specific building and the closest stops from that building. The `name` column contains information about the names of the buildings which we can use to choose a building of our interest for visualization:

```{python}
#| echo: true
# Find unique building names
k_nearest.name.unique()
```
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## KDTree
As we can see, one of the buildings is called `Hartwall Arena` which is an interesting example because it is a large sports arena that is reached by thousands of people via public transport whenever there is some event happening. Thus, let's filter the data for that building and create an interactive map out of the results, showing the three closest stops indicated with different colors:

```{python}
#| echo: true
# Visualize 3 nearest stops to
selected_name = "Hartwall Arena"

m = k_nearest_1.loc[k_nearest_1["name"] == selected_name].explore(
    color="red", tiles="CartoDB Positron", max_zoom=16
)
m = k_nearest_2.loc[k_nearest_2["name"] == selected_name].explore(m=m, color="orange")
m = k_nearest_3.loc[k_nearest_3["name"] == selected_name].explore(m=m, color="blue")
m = stops.explore(m=m, color="green")
m
```
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## Nearest neighbors within radius
As a last example related to nearest neighbors we show how to find all neighbors of a given Point geometry within a specific distance threshold. As a practical example, we aim to find and calculate the number of buildings that are within 200 meters from a given public transport stop. Doing this kind of nearest neighbor query is similar to the one that we did with `.sjoin_nearest()` using the `max_distance` parameter, but here we aim to efficiently retrieve all neighbors within the given search radius, not only the closest one which is how `sjoin_nearest()` operates. Finding all neighbors within a specific search radius can also be done using the KD-Tree spatial index. However, in this case we actually build the `KDTree` index for both datasets (buildings and stops) and then use a `.query_ball_tree()` method to find all neighbors within the radius `r`: 

```{python}
#| echo: true
from scipy.spatial import KDTree

# Build KDTree indices
stop_kdt = KDTree(stop_coords)
building_kdt = KDTree(building_coords)

# Find the three nearest neighbors from stop KD-Tree for each building
k_nearest_ix = stop_kdt.query_ball_tree(building_kdt, r=200)
```

```{python}
#| echo: true
len(k_nearest_ix)
```
:::
## K-Nearest Neighbor search
:::{.callout-note icon=false}
## Nearest neighbors within radius
Now we have found all the building points within 200 meters from the stops (n=8377). As a result, we get a list of building index values for each stop. The following shows all the indices for the first stop at index 0:

```{python}
#| echo: true
k_nearest_ix[0]
```

```
[1129,
 1130,
 1155,
 2054,
 2055,
 2056,
... (output truncated)
```
:::

## K-Nearest Neighbor search
:::{.callout-note icon=false}
## Nearest neighbors within radius
Now we can easily store the building indices as a new column to the `stops` `GeoDataFrame`:

```{python}
#| echo: true
stops["building_ids_within_range"] = k_nearest_ix
stops.head()
```

With this information, we can for example calculate the number of buildings within 200 meters from each stop. To do this, we can create a simple `lambda` function that checks the length of the id-list and store the result into column `building_cnt`:

```{python}
#| echo: true
stops["building_cnt"] = stops["building_ids_within_range"].apply(
    lambda id_list: len(id_list)
)
stops.head()
```

```{python}
#| echo: true
print("Max number of buildings:", stops["building_cnt"].max())
print("Average number of buildings:", stops["building_cnt"].mean().round(1))
```
:::
## K-Nearest Neighbor search
:::{.callout-note icon=false}
## Nearest neighbors within radius
By calculating simple statistics from the `building_cnt` column, we can see that on average there are 32.2 buildings within 200 meters from the public transport stops and the maximum number of buildings within this distance is whopping 181 buildings. This indicates very dense neighborhood having numerous buildings in a small area. To better understand, where this kind of neighborhood is located and what does it look like, we can make a map by selecting the rows with highest number of buildings and then plotting the stop and building points within radius:

```{python}
#| echo: true
filtered = stops["building_cnt"] == stops["building_cnt"].max()
building_ids = stops.loc[filtered].building_ids_within_range.values[0]

m = stops.loc[filtered].explore(
    tiles="CartoDB Positron", color="red", marker_kwds={"radius": 5}, max_zoom=16
)
building_points.loc[building_ids].explore(m=m)
```
<!-- #region editable=true slideshow={"slide_type": ""} tags=["question"] -->
## K-Nearest Neighbor search
:::{.callout-note icon=false}
## Exercise

Test and try to find all buildings within 200 meters from the transit stops by creating a 200 meter buffer around the stops and then making a spatial join between the buffers and building points. Calculate the number of buildings per stop_id. Did it take longer to find the nearest buildings using this approach?

<!--
```python editable=true slideshow={"slide_type": ""} tags=["remove_book_cell", "hide-cell"]
# Solution

# Create a 200 meter buffer
stop_buffer = stops.copy()
stop_buffer["geometry"] = stops.buffer(200)

# Find all the building points intersecting with the buffer
buffer_buildings = stop_buffer.sjoin(building_points, predicate="intersects")

# Calculate the number of buildings per stop by grouping
building_count = (
    buffer_buildings.groupby("stop_id").stop_name.count().to_frame().reset_index()
)

# Now the "stop_name" column contains information about building count, rename
building_count = building_count.rename(columns={"stop_name": "building_cnt_buffer"})

# Join the information into the stops
stop_buffer = stop_buffer.merge(building_count, on="stop_id")

# As a result, we should have identical number of buildings identified per stop (see the last two columns)
stop_buffer.head()
```
-->
