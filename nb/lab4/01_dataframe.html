<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>dataframe – Big Data analytics / Applied Data analytics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Big Data analytics / Applied Data analytics</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../bigdata.html"> 
<span class="menu-text">Big Data analytics</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../applied.html"> 
<span class="menu-text">Applied Data analytics</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#dask-dataframe---parallelized-pandas" id="toc-dask-dataframe---parallelized-pandas" class="nav-link active" data-scroll-target="#dask-dataframe---parallelized-pandas">Dask DataFrame - parallelized pandas</a>
  <ul class="collapse">
  <li><a href="#when-to-use-dask.dataframe" id="toc-when-to-use-dask.dataframe" class="nav-link" data-scroll-target="#when-to-use-dask.dataframe">When to use <code>dask.dataframe</code></a></li>
  <li><a href="#create-datasets" id="toc-create-datasets" class="nav-link" data-scroll-target="#create-datasets">Create datasets</a></li>
  <li><a href="#suppress-futurewarnings" id="toc-suppress-futurewarnings" class="nav-link" data-scroll-target="#suppress-futurewarnings">Suppress FutureWarnings</a></li>
  <li><a href="#set-up-your-local-cluster" id="toc-set-up-your-local-cluster" class="nav-link" data-scroll-target="#set-up-your-local-cluster">Set up your local cluster</a>
  <ul class="collapse">
  <li><a href="#dask-diagnostic-dashboard" id="toc-dask-diagnostic-dashboard" class="nav-link" data-scroll-target="#dask-diagnostic-dashboard">Dask Diagnostic Dashboard</a></li>
  </ul></li>
  <li><a href="#reading-and-working-with-datasets" id="toc-reading-and-working-with-datasets" class="nav-link" data-scroll-target="#reading-and-working-with-datasets">Reading and working with datasets</a>
  <ul class="collapse">
  <li><a href="#lazy-evaluation" id="toc-lazy-evaluation" class="nav-link" data-scroll-target="#lazy-evaluation">Lazy Evaluation</a></li>
  <li><a href="#reading-from-remote-storage" id="toc-reading-from-remote-storage" class="nav-link" data-scroll-target="#reading-from-remote-storage">Reading from remote storage</a></li>
  </ul></li>
  <li><a href="#computations-with-dask.dataframe" id="toc-computations-with-dask.dataframe" class="nav-link" data-scroll-target="#computations-with-dask.dataframe">Computations with <code>dask.dataframe</code></a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises">Exercises</a>
  <ul class="collapse">
  <li><a href="#how-many-rows-are-in-our-dataset" id="toc-how-many-rows-are-in-our-dataset" class="nav-link" data-scroll-target="#how-many-rows-are-in-our-dataset">1. How many rows are in our dataset?</a></li>
  <li><a href="#in-total-how-many-non-canceled-flights-were-taken" id="toc-in-total-how-many-non-canceled-flights-were-taken" class="nav-link" data-scroll-target="#in-total-how-many-non-canceled-flights-were-taken">2. In total, how many non-canceled flights were taken?</a></li>
  <li><a href="#in-total-how-many-non-canceled-flights-were-taken-from-each-airport" id="toc-in-total-how-many-non-canceled-flights-were-taken-from-each-airport" class="nav-link" data-scroll-target="#in-total-how-many-non-canceled-flights-were-taken-from-each-airport">3. In total, how many non-canceled flights were taken from each airport?</a></li>
  <li><a href="#what-was-the-average-departure-delay-from-each-airport" id="toc-what-was-the-average-departure-delay-from-each-airport" class="nav-link" data-scroll-target="#what-was-the-average-departure-delay-from-each-airport">4. What was the average departure delay from each airport?</a></li>
  <li><a href="#what-day-of-the-week-has-the-worst-average-departure-delay" id="toc-what-day-of-the-week-has-the-worst-average-departure-delay" class="nav-link" data-scroll-target="#what-day-of-the-week-has-the-worst-average-departure-delay">5. What day of the week has the worst average departure delay?</a></li>
  <li><a href="#lets-say-the-distance-column-is-erroneous-and-you-need-to-add-1-to-all-values-how-would-you-do-this" id="toc-lets-say-the-distance-column-is-erroneous-and-you-need-to-add-1-to-all-values-how-would-you-do-this" class="nav-link" data-scroll-target="#lets-say-the-distance-column-is-erroneous-and-you-need-to-add-1-to-all-values-how-would-you-do-this">6. Let’s say the distance column is erroneous and you need to add 1 to all values, how would you do this?</a></li>
  </ul></li>
  <li><a href="#sharing-intermediate-results" id="toc-sharing-intermediate-results" class="nav-link" data-scroll-target="#sharing-intermediate-results">Sharing Intermediate Results</a>
  <ul class="collapse">
  <li><a href="#dask.compute" id="toc-dask.compute" class="nav-link" data-scroll-target="#dask.compute"><code>dask.compute</code></a></li>
  <li><a href="#persist" id="toc-persist" class="nav-link" data-scroll-target="#persist"><code>.persist()</code></a></li>
  </ul></li>
  <li><a href="#custom-code-with-dask-dataframe" id="toc-custom-code-with-dask-dataframe" class="nav-link" data-scroll-target="#custom-code-with-dask-dataframe">Custom code with Dask DataFrame</a>
  <ul class="collapse">
  <li><a href="#what-is-meta" id="toc-what-is-meta" class="nav-link" data-scroll-target="#what-is-meta">What is <code>meta</code>?</a></li>
  </ul></li>
  <li><a href="#close-you-local-dask-cluster" id="toc-close-you-local-dask-cluster" class="nav-link" data-scroll-target="#close-you-local-dask-cluster">Close you local Dask Cluster</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<p><img src="http://dask.readthedocs.io/en/latest/_images/dask_horizontal.svg" align="right" width="30%" alt="Dask logo\"></p>
<section id="dask-dataframe---parallelized-pandas" class="level1">
<h1>Dask DataFrame - parallelized pandas</h1>
<p>Looks and feels like the pandas API, but for parallel and distributed workflows.</p>
<p>At its core, the <code>dask.dataframe</code> module implements a “blocked parallel” <code>DataFrame</code> object that looks and feels like the pandas API, but for parallel and distributed workflows. One Dask <code>DataFrame</code> is comprised of many in-memory pandas <code>DataFrame</code>s separated along the index. One operation on a Dask <code>DataFrame</code> triggers many pandas operations on the constituent pandas <code>DataFrame</code>s in a way that is mindful of potential parallelism and memory constraints.</p>
<p><img src="https://docs.dask.org/en/stable/_images/dask-dataframe.svg" align="right" width="30%" alt="Dask DataFrame is composed of pandas DataFrames"></p>
<p><strong>Related Documentation</strong></p>
<ul>
<li><a href="https://docs.dask.org/en/latest/dataframe.html">DataFrame documentation</a></li>
<li><a href="https://youtu.be/AT2XtFehFSQ">DataFrame screencast</a></li>
<li><a href="https://docs.dask.org/en/latest/dataframe-api.html">DataFrame API</a></li>
<li><a href="https://examples.dask.org/dataframe.html">DataFrame examples</a></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/">pandas documentation</a></li>
</ul>
<section id="when-to-use-dask.dataframe" class="level2">
<h2 class="anchored" data-anchor-id="when-to-use-dask.dataframe">When to use <code>dask.dataframe</code></h2>
<p>pandas is great for tabular datasets that fit in memory. A general rule of thumb for pandas is:</p>
<blockquote class="blockquote">
<dl>
<dt>“Have 5 to 10 times as much RAM as the size of your dataset”</dt>
<dd>
<p>Wes McKinney (2017) in <a href="https://wesmckinney.com/blog/apache-arrow-pandas-internals/">10 things I hate about pandas</a></p>
</dd>
</dl>
</blockquote>
<p>Here “size of dataset” means dataset size on <em>the disk</em>.</p>
<p>Dask becomes useful when the datasets exceed the above rule.</p>
<p>In this notebook, you will be working with the New York City Airline data. This dataset is only ~200MB, so that you can download it in a reasonable time, but <code>dask.dataframe</code> will scale to datasets <strong>much</strong> larger than memory.</p>
</section>
<section id="create-datasets" class="level2">
<h2 class="anchored" data-anchor-id="create-datasets">Create datasets</h2>
<p>Create the datasets you will be using in this notebook:</p>
<div id="cell-4" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This step is not necessary - dataset is already downloaded</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#%run prep.py -d flights</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="suppress-futurewarnings" class="level2">
<h2 class="anchored" data-anchor-id="suppress-futurewarnings">Suppress FutureWarnings</h2>
<div id="cell-6" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">'ignore'</span>, category<span class="op">=</span><span class="pp">FutureWarning</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="set-up-your-local-cluster" class="level2">
<h2 class="anchored" data-anchor-id="set-up-your-local-cluster">Set up your local cluster</h2>
<p>Create a local Dask cluster and connect it to the client. Don’t worry about this bit of code for now, you will learn more in the Distributed notebook.</p>
<div id="cell-9" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dask.distributed <span class="im">import</span> Client</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>client <span class="op">=</span> Client(n_workers<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>client</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="dask-diagnostic-dashboard" class="level3">
<h3 class="anchored" data-anchor-id="dask-diagnostic-dashboard">Dask Diagnostic Dashboard</h3>
<p>Dask Distributed provides a useful Dashboard to visualize the state of your cluster and computations.</p>
<p>If you’re on <strong>JupyterLab or Binder</strong>, you can use the <a href="https://github.com/dask/dask-labextension">Dask JupyterLab extension</a> (which should be already installed in your environment) to open the dashboard plots: * Click on the Dask logo in the left sidebar * Click on the magnifying glass icon, which will automatically connect to the active dashboard (if that doesn’t work, you can type/paste the dashboard link http://127.0.0.1:8787 in the field) * Click on <strong>“Task Stream”</strong>, <strong>“Progress Bar”</strong>, and <strong>“Worker Memory”</strong>, which will open these plots in new tabs * Re-organize the tabs to suit your workflow!</p>
<p>Alternatively, click on the dashboard link displayed in the Client details above: http://127.0.0.1:8787/status. It will open a new browser tab with the Dashboard.</p>
</section>
</section>
<section id="reading-and-working-with-datasets" class="level2">
<h2 class="anchored" data-anchor-id="reading-and-working-with-datasets">Reading and working with datasets</h2>
<p>Let’s read an extract of flights in the USA across several years. This data is specific to flights out of the three airports in the New York City area.</p>
<div id="cell-12" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dask</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>By convention, we import the module <code>dask.dataframe</code> as <code>dd</code>, and call the corresponding <code>DataFrame</code> object <code>ddf</code>.</p>
<p><strong>Note</strong>: The term “Dask DataFrame” is slightly overloaded. Depending on the context, it can refer to the module or the DataFrame object. To avoid confusion, throughout this notebook: - <code>dask.dataframe</code> (note the all lowercase) refers to the API, and - <code>DataFrame</code> (note the CamelCase) refers to the object.</p>
<p>The following filename includes a glob pattern <code>*</code>, so all files in the path matching that pattern will be read into the same <code>DataFrame</code>.</p>
<div id="cell-14" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dask.dataframe <span class="im">as</span> dd</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>ddf <span class="op">=</span> dd.read_csv(</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    os.path.join(<span class="st">"data"</span>, <span class="st">"nycflights"</span>, <span class="st">"*.csv"</span>), parse_dates<span class="op">=</span>{<span class="st">"Date"</span>: [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]}</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>ddf</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Dask has not loaded the data yet, it has: - investigated the input path and found that there are ten matching files - intelligently created a set of jobs for each chunk – one per original CSV file in this case</p>
<p>Notice that the representation of the <code>DataFrame</code> object contains no data - Dask has just done enough to read the start of the first file, and infer the column names and dtypes.</p>
<section id="lazy-evaluation" class="level3">
<h3 class="anchored" data-anchor-id="lazy-evaluation">Lazy Evaluation</h3>
<p>Most Dask Collections, including Dask <code>DataFrame</code> are evaluated lazily, which means Dask constructs the logic (called task graph) of your computation immediately but “evaluates” them only when necessary. You can view this task graph using <code>.visualize()</code>.</p>
<p>You will learn more about this in the Delayed notebook, but for now, note that we need to call <code>.compute()</code> to trigger actual computations.</p>
<div id="cell-18" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ddf.visualize()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Some functions like <code>len</code> and <code>head</code> also trigger a computation. Specifically, calling <code>len</code> will: - load actual data, (that is, load each file into a pandas DataFrame) - then apply the corresponding functions to each pandas DataFrame (also known as a partition) - combine the subtotals to give you the final grand total</p>
<div id="cell-20" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load and count number of rows</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(ddf)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>You can view the start and end of the data as you would in pandas:</p>
<div id="cell-22" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>ddf.head()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ddf.tail()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ValueError: Mismatched dtypes found in `pd.read_csv`/`pd.read_table`.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"># +----------------+---------+----------+</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># | Column         | Found   | Expected |</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"># +----------------+---------+----------+</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co"># | CRSElapsedTime | float64 | int64    |</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co"># | TailNum        | object  | float64  |</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co"># +----------------+---------+----------+</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co"># The following columns also raised exceptions on conversion:</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co"># - TailNum</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">#   ValueError("could not convert string to float: 'N54711'")</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Usually this is due to dask's dtype inference failing, and</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co"># *may* be fixed by specifying dtypes manually by adding:</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="co"># dtype={'CRSElapsedTime': 'float64',</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co">#        'TailNum': 'object'}</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="co"># to the call to `read_csv`/`read_table`.</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Unlike <code>pandas.read_csv</code> which reads in the entire file before inferring datatypes, <code>dask.dataframe.read_csv</code> only reads in a sample from the beginning of the file (or first file if using a glob). These inferred datatypes are then enforced when reading all partitions.</p>
<p>In this case, the datatypes inferred in the sample are incorrect. The first <code>n</code> rows have no value for <code>CRSElapsedTime</code> (which pandas infers as a <code>float</code>), and later on turn out to be strings (<code>object</code> dtype). Note that Dask gives an informative error message about the mismatch. When this happens you have a few options:</p>
<ul>
<li>Specify dtypes directly using the <code>dtype</code> keyword. This is the recommended solution, as it’s the least error prone (better to be explicit than implicit) and also the most performant.</li>
<li>Increase the size of the <code>sample</code> keyword (in bytes)</li>
<li>Use <code>assume_missing</code> to make <code>dask</code> assume that columns inferred to be <code>int</code> (which don’t allow missing values) are actually <code>floats</code> (which do allow missing values). In our particular case this doesn’t apply.</li>
</ul>
<p>In our case we’ll use the first option and directly specify the <code>dtypes</code> of the offending columns.</p>
<div id="cell-25" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>ddf <span class="op">=</span> dd.read_csv(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    os.path.join(<span class="st">"data"</span>, <span class="st">"nycflights"</span>, <span class="st">"*.csv"</span>),</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">#parse_dates={"Date": [0, 1, 2]},</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    dtype<span class="op">=</span>{<span class="st">"TailNum"</span>: <span class="bu">str</span>, <span class="st">"CRSElapsedTime"</span>: <span class="bu">float</span>, <span class="st">"Cancelled"</span>: <span class="bu">bool</span>},</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-26" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ddf.tail()  <span class="co"># now works</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="reading-from-remote-storage" class="level3">
<h3 class="anchored" data-anchor-id="reading-from-remote-storage">Reading from remote storage</h3>
<p>If you’re thinking about distributed computing, your data is probably stored remotely on services (like Amazon’s S3 or Google’s cloud storage) and is in a friendlier format (like Parquet). Dask can read data in various formats directly from these remote locations <strong>lazily</strong> and <strong>in parallel</strong>.</p>
<p>Here’s how you can read the NYC taxi cab data from Amazon S3:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ddf <span class="op">=</span> dd.read_parquet(</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"s3://nyc-tlc/trip data/yellow_tripdata_2012-*.parquet"</span>,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You can also leverage Parquet-specific optimizations like column selection and metadata handling, learn more in <a href="https://docs.dask.org/en/stable/dataframe-parquet.html">the Dask documentation on working with Parquet files</a>.</p>
</section>
</section>
<section id="computations-with-dask.dataframe" class="level2">
<h2 class="anchored" data-anchor-id="computations-with-dask.dataframe">Computations with <code>dask.dataframe</code></h2>
<p>Let’s compute the maximum of the flight delay.</p>
<p>With just pandas, we would loop over each file to find the individual maximums, then find the final maximum over all the individual maximums.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> os.listdir(os.path.join(<span class="st">'data'</span>, <span class="st">'nycflights'</span>))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>maxes <span class="op">=</span> []</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> files:</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_csv(os.path.join(<span class="st">'data'</span>, <span class="st">'nycflights'</span>, <span class="bu">file</span>))</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    maxes.append(df.DepDelay.<span class="bu">max</span>())</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>final_max <span class="op">=</span> <span class="bu">max</span>(maxes)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><code>dask.dataframe</code> lets us write pandas-like code, that operates on larger-than-memory datasets in parallel.</p>
<div id="cell-29" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> ddf.DepDelay.<span class="bu">max</span>()</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>result.compute()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>This creates the lazy computation for us and then runs it.</p>
<p><strong>Note:</strong> Dask will delete intermediate results (like the full pandas DataFrame for each file) as soon as possible. This means you can handle datasets that are larger than memory but, repeated computations will have to load all of the data in each time. (Run the code above again, is it faster or slower than you would expect?)</p>
<p>You can view the underlying task graph using <code>.visualize()</code>:</p>
<div id="cell-33" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># notice the parallelism</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>result.visualize()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="exercises" class="level2">
<h2 class="anchored" data-anchor-id="exercises">Exercises</h2>
<p>In this section you will do a few <code>dask.dataframe</code> computations. If you are comfortable with pandas then these should be familiar. You will have to think about when to call <code>.compute()</code>.</p>
<section id="how-many-rows-are-in-our-dataset" class="level3">
<h3 class="anchored" data-anchor-id="how-many-rows-are-in-our-dataset">1. How many rows are in our dataset?</h3>
<p><em>Hint</em>: how would you check how many items are in a list?</p>
<div id="cell-36" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Your code here</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="in-total-how-many-non-canceled-flights-were-taken" class="level3">
<h3 class="anchored" data-anchor-id="in-total-how-many-non-canceled-flights-were-taken">2. In total, how many non-canceled flights were taken?</h3>
<p><em>Hint</em>: use <a href="https://pandas.pydata.org/pandas-docs/stable/indexing.html#boolean-indexing">boolean indexing</a>.</p>
<div id="cell-38" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Your code here</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="in-total-how-many-non-canceled-flights-were-taken-from-each-airport" class="level3">
<h3 class="anchored" data-anchor-id="in-total-how-many-non-canceled-flights-were-taken-from-each-airport">3. In total, how many non-canceled flights were taken from each airport?</h3>
<p><em>Hint</em>: use <a href="https://pandas.pydata.org/pandas-docs/stable/groupby.html">groupby</a>.</p>
<div id="cell-40" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Your code here</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="what-was-the-average-departure-delay-from-each-airport" class="level3">
<h3 class="anchored" data-anchor-id="what-was-the-average-departure-delay-from-each-airport">4. What was the average departure delay from each airport?</h3>
<div id="cell-42" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Your code here</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="what-day-of-the-week-has-the-worst-average-departure-delay" class="level3">
<h3 class="anchored" data-anchor-id="what-day-of-the-week-has-the-worst-average-departure-delay">5. What day of the week has the worst average departure delay?</h3>
<div id="cell-44" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Your code here</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="lets-say-the-distance-column-is-erroneous-and-you-need-to-add-1-to-all-values-how-would-you-do-this" class="level3">
<h3 class="anchored" data-anchor-id="lets-say-the-distance-column-is-erroneous-and-you-need-to-add-1-to-all-values-how-would-you-do-this">6. Let’s say the distance column is erroneous and you need to add 1 to all values, how would you do this?</h3>
<div id="cell-46" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Your code here</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
</section>
<section id="sharing-intermediate-results" class="level2">
<h2 class="anchored" data-anchor-id="sharing-intermediate-results">Sharing Intermediate Results</h2>
<p>When computing all of the above, we sometimes did the same operation more than once. For most operations, <code>dask.dataframe</code> stores the arguments, allowing duplicate computations to be shared and only computed once.</p>
<p>For example, let’s compute the mean and standard deviation for departure delay of all non-canceled flights. Since Dask operations are lazy, those values aren’t the final results yet. They’re just the steps required to get the result.</p>
<p>If you compute them with two calls to compute, there is no sharing of intermediate computations.</p>
<div id="cell-48" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>non_canceled <span class="op">=</span> ddf[<span class="op">~</span>ddf.Cancelled]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>mean_delay <span class="op">=</span> non_canceled.DepDelay.mean()</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>std_delay <span class="op">=</span> non_canceled.DepDelay.std()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-49" class="cell" data-tags="[]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>mean_delay_res <span class="op">=</span> mean_delay.compute()</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>std_delay_res <span class="op">=</span> std_delay.compute()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="dask.compute" class="level3">
<h3 class="anchored" data-anchor-id="dask.compute"><code>dask.compute</code></h3>
<p>But let’s try by passing both to a single <code>compute</code> call.</p>
<div id="cell-52" class="cell" data-tags="[]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>mean_delay_res, std_delay_res <span class="op">=</span> dask.compute(mean_delay, std_delay)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Using <code>dask.compute</code> takes roughly 1/2 the time. This is because the task graphs for both results are merged when calling <code>dask.compute</code>, allowing shared operations to only be done once instead of twice. In particular, using <code>dask.compute</code> only does the following once:</p>
<ul>
<li>the calls to <code>read_csv</code></li>
<li>the filter (<code>df[~df.Cancelled]</code>)</li>
<li>some of the necessary reductions (<code>sum</code>, <code>count</code>)</li>
</ul>
<p>To see what the merged task graphs between multiple results look like (and what’s shared), you can use the <code>dask.visualize</code> function (you might want to use <code>filename='graph.pdf'</code> to save the graph to disk so that you can zoom in more easily):</p>
<div id="cell-55" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>dask.visualize(mean_delay, std_delay)<span class="co">#, engine="cytoscape") # optionally we can use a different visualization engine</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="persist" class="level3">
<h3 class="anchored" data-anchor-id="persist"><code>.persist()</code></h3>
<p>While using a distributed scheduler (you will learn more about schedulers in the upcoming notebooks), you can keep some <em>data that you want to use often</em> in the <em>distributed memory</em>.</p>
<p><code>persist</code> generates “Futures” (more on this later as well) and stores them in the same structure as your output. You can use <code>persist</code> with any data or computation that fits in memory.</p>
<p>If you want to analyze data only for non-canceled flights departing from JFK airport, you can either have two compute calls like in the previous section:</p>
<div id="cell-58" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>non_cancelled <span class="op">=</span> ddf[<span class="op">~</span>ddf.Cancelled]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>ddf_jfk <span class="op">=</span> non_cancelled[non_cancelled.Origin <span class="op">==</span> <span class="st">"JFK"</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-59" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>ddf_jfk.DepDelay.mean().compute()</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>ddf_jfk.DepDelay.<span class="bu">sum</span>().compute()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Or, consider persisting that subset of data in memory.</p>
<p>See the “Graph” dashboard plot, the red squares indicate persisted data stored as Futures in memory. You will also notice an increase in Worker Memory (another dashboard plot) consumption.</p>
<div id="cell-61" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>ddf_jfk <span class="op">=</span> ddf_jfk.persist()  <span class="co"># returns back control immediately</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-62" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>ddf_jfk.DepDelay.mean().compute()</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>ddf_jfk.DepDelay.std().compute()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Analyses on this persisted data is faster because we are not repeating the loading and selecting (non-canceled, JFK departure) operations.</p>
</section>
</section>
<section id="custom-code-with-dask-dataframe" class="level2">
<h2 class="anchored" data-anchor-id="custom-code-with-dask-dataframe">Custom code with Dask DataFrame</h2>
<p><code>dask.dataframe</code> only covers a small but well-used portion of the pandas API.</p>
<p>This limitation is for two reasons:</p>
<ol type="1">
<li>The Pandas API is <em>huge</em></li>
<li>Some operations are genuinely hard to do in parallel, e.g, sorting.</li>
</ol>
<p>Additionally, some important operations like <code>set_index</code> work, but are slower than in pandas because they include substantial shuffling of data, and may write out to disk.</p>
<p><strong>What if you want to use some custom functions that aren’t (or can’t be) implemented for Dask DataFrame yet?</strong></p>
<p>You can open an issue on the <a href="https://github.com/dask/dask/issues">Dask issue tracker</a> to check how feasible the function could be to implement, and you can consider contributing this function to Dask.</p>
<p>In case it’s a custom function or tricky to implement, <code>dask.dataframe</code> provides a few methods to make applying custom functions to Dask DataFrames easier:</p>
<ul>
<li><a href="https://docs.dask.org/en/latest/generated/dask.dataframe.DataFrame.map_partitions.html"><code>map_partitions</code></a>: to run a function on each partition (each pandas DataFrame) of the Dask DataFrame</li>
<li><a href="https://docs.dask.org/en/latest/generated/dask.dataframe.rolling.map_overlap.html"><code>map_overlap</code></a>: to run a function on each partition (each pandas DataFrame) of the Dask DataFrame, with some rows shared between neighboring partitions</li>
<li><a href="https://docs.dask.org/en/latest/generated/dask.dataframe.Series.reduction.html"><code>reduction</code></a>: for custom row-wise reduction operations.</li>
</ul>
<p>Let’s take a quick look at the <code>map_partitions()</code> function:</p>
<div id="cell-66" class="cell" data-tags="[]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="bu">help</span>(ddf.map_partitions)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The “Distance” column in <code>ddf</code> is currently in miles. Let’s say we want to convert the units to kilometers and we have a general helper function as shown below. In this case, we can use <code>map_partitions</code> to apply this function across each of the internal pandas <code>DataFrame</code>s in parallel.</p>
<div id="cell-68" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> my_custom_converter(df, multiplier<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df <span class="op">*</span> multiplier</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>meta <span class="op">=</span> pd.Series(name<span class="op">=</span><span class="st">"Distance"</span>, dtype<span class="op">=</span><span class="st">"float64"</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>distance_km <span class="op">=</span> ddf.Distance.map_partitions(</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    my_custom_converter, multiplier<span class="op">=</span><span class="fl">0.6</span>, meta<span class="op">=</span>meta</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-69" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>distance_km.visualize()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-70" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>distance_km.head()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="what-is-meta" class="level3">
<h3 class="anchored" data-anchor-id="what-is-meta">What is <code>meta</code>?</h3>
<p>Since Dask operates lazily, it doesn’t always have enough information to infer the output structure (which includes datatypes) of certain operations.</p>
<p><code>meta</code> is a <em>suggestion</em> to Dask about the output of your computation. Importantly, <code>meta</code> <em>never infers with the output structure</em>. Dask uses this <code>meta</code> until it can determine the actual output structure.</p>
<p>Even though there are many ways to define <code>meta</code>, we suggest using a small pandas Series or DataFrame that matches the structure of your final output.</p>
</section>
</section>
<section id="close-you-local-dask-cluster" class="level2">
<h2 class="anchored" data-anchor-id="close-you-local-dask-cluster">Close you local Dask Cluster</h2>
<p>It’s good practice to always close any Dask cluster you create:</p>
<div id="cell-74" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>client.shutdown()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/dslnu\.github\.io\/data_analytics\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>